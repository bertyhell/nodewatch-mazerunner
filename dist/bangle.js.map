{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utils.ts","webpack:///./src/engine.ts","webpack:///./src/bangle.ts","webpack:///./node_modules/process/browser.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","lastTraceTime","times","stopTrace","trace","time","Date","getTime","timeDelta","avgTime","traces","keys","forEach","console","log","clampDeg","deg","cos","Math","PI","sin","tan","getSquareDistance","x1","y1","x2","y2","isOutsideMaze","maze","location","x","length","y","getUnvisitedNeighbors","currentPosition","filter","neighbor","generateMaze","width","height","generatedMaze","Array","row","col","unvisitedNeighbors","min","max","stack","push","pop","unvisitedNeighbor","floor","random","lastPlayerX","lastPlayerY","lastPlayerAngle","SKIP_RENDER_RAYS","mazeWidth","mazeHeight","playerAngle","gameVars","screenWidth","screenHeight","viewAngleWidth","angleStep","playerStepSize","mazeHorCells","mazeVerCells","playerX","playerY","startGame","screenIo","stopGame","running","getCollisionDistance","viewAngle","outerRay","debugOperations","horCollision","vertCollision","initialHorIntersectionX","initialHorIntersectionY","initialVertIntersectionX","initialVertIntersectionY","horizontalOffsetX","horizontalOffsetY","verticalOffsetX","verticalOffsetY","isFacingUp","isFacingRight","horIntersectionX","horIntersectionY","horGridLocation","vertIntersectionX","vertIntersectionY","vertGridLocation","quadrant","intersectionOffset","drawDebugPixel","abs","closestCollision","drawDebugLine","Error","isInsideWall","movePlayer","deltaX","deltaY","newPlayerX","newPlayerY","onFrame","BTN4","read","BTN5","playerXDelta","playerYDelta","BTN1","BTN2","clear","drawDebugGrid","startAngle","raytraceStepAngle","anglesCollisionsAndDistances","collision","perpendicularDistance","sqrt","angle","distance","shouldDrawWall","intersectionPoints","angCollDis","intersectionX","round","intersectionY","CORNERS","cornerIntersectionPoints","intersectionKey","intersection","topLeftCell","topRightCell","bottomLeftCell","bottomRightCell","shortestDistance","closestCollisionIndex","collisionInfo","index","wallHeight","drawVerticalLine","drawPixel","drawWalls","flip","setTimeout","gameVariables","Bangle","setLCDMode","BTN3","color","g","setPixel","drawLine","setFontAlign","drawString","getHeight","process","version","checkForStart","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","e","this","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","arguments","apply","title","browser","env","argv","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask"],"mappings":"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","file":"bangle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import { MazeElement, Point } from './types';\r\n\r\n// const initialTime = new Date().getTime();\r\n\r\nconst times: {[name: string]: {avgTime: number, traces: number}} = {};\r\nlet lastTraceTime: number;\r\nlet stopTrace = false;\r\n\r\nexport function trace(name: string): void {\r\n\tif (stopTrace) {\r\n\t\treturn;\r\n\t}\r\n\tconst time = new Date().getTime();\r\n\tif (lastTraceTime) {\r\n\t\tconst timeDelta = time - lastTraceTime;\r\n\t  if (times[name]) {\r\n\t  \ttimes[name].avgTime = (times[name].avgTime * times[name].traces + timeDelta) / (times[name].traces + 1);\r\n\t  \ttimes[name].traces += 1;\r\n\t\t} else {\r\n\t  \ttimes[name] = {\r\n\t  \t\tavgTime: timeDelta,\r\n\t\t\t\ttraces: 1,\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tlastTraceTime = time;\r\n\r\n\tif (times[name] && times[name].traces === 10) {\r\n\t\tObject.keys(times).forEach(key => {\r\n\t\t\tconsole.log(key + ';' + times[key].avgTime);\r\n\t\t});\r\n\t\tstopTrace = true;\r\n\t}\r\n}\r\n\r\n// export function printFreeSpace(name?: string): void {\r\n// \tif (!(process as any).memory) {\r\n// \t\treturn;\r\n// \t}\r\n// \tconst time = Math.floor(new Date().getTime() - initialTime);\r\n// \tconsole.log((name || 'free memory') + '; ' + time + '; ' + (process as any).memory().free);\r\n// }\r\n\r\nexport function clampDeg(deg: number): number {\r\n\treturn (deg + 360) % 360;\r\n}\r\n\r\n\r\n// /**\r\n//  * Generates a lookup table for trigonometric functions\r\n//  * The keys will be the degrees times 10, so we can easily round to 0.1 degree\r\n//  * @param trigonometricFunction\r\n//  */\r\n// function getLookupTable(trigonometricFunction: (rad: number) => number): { [deg: number]: number } {\r\n// \tconst lookup: { [deg: number]: number } = {};\r\n// \tfor (let i = 0; i <= 360; i += 1) {\r\n// \t\tlookup[Math.round(i)] = trigonometricFunction(i / 180 * Math.PI);\r\n// \t}\r\n// \treturn lookup;\r\n// }\r\n//\r\n// const cosLookupTable: { [deg: number]: number } = getLookupTable(Math.cos);\r\n// const sinLookupTable: { [deg: number]: number } = getLookupTable(Math.sin);\r\n// const tanLookupTable: { [deg: number]: number } = getLookupTable(Math.tan);\r\n//\r\n// function lookupAndInterpolate(deg: number, lookupTable: { [deg: number]: number }): number {\r\n// \tconst lowerDeg = Math.floor(deg);\r\n// \tconst upperDeg = Math.ceil(deg + 0.00001);\r\n// \tconst lowerTri = lookupTable[lowerDeg];\r\n// \tconst upperTri = lookupTable[upperDeg];\r\n// \tconst diffDeg = upperDeg - lowerDeg;\r\n// \tconst diffCos = upperTri - lowerTri;\r\n// \treturn lowerTri + Math.abs(deg - lowerDeg) / diffDeg * diffCos;\r\n// }\r\n\r\n// export function cos(deg: number): number {\r\n// \treturn lookupAndInterpolate(deg, cosLookupTable);\r\n// }\r\n//\r\n// export function sin(deg: number): number {\r\n// \treturn lookupAndInterpolate(deg, sinLookupTable);\r\n// }\r\n//\r\n// export function tan(deg: number): number {\r\n// \treturn lookupAndInterpolate(deg, tanLookupTable);\r\n// }\r\n\r\nexport function cos(deg: number): number {\r\n\treturn Math.cos(deg / 180 * Math.PI);\r\n}\r\n\r\nexport function sin(deg: number): number {\r\n\treturn Math.sin(deg / 180 * Math.PI);\r\n}\r\n\r\nexport function tan(deg: number): number {\r\n\treturn Math.tan(deg / 180 * Math.PI);\r\n}\r\n\r\nexport function getSquareDistance(x1: number, y1: number, x2: number, y2: number) {\r\n\treturn (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n}\r\n\r\nexport function isOutsideMaze(maze: MazeElement[][], location: Point): boolean {\r\n\treturn !(location.x >= 0 && location.x < maze[0].length && location.y >= 0 && location.y < maze.length);\r\n}\r\n\r\nfunction getUnvisitedNeighbors(maze: MazeElement[][], currentPosition: Point): Point[] {\r\n\tconst neighbors: Point[] = [\r\n\t\t{ x: currentPosition.x - 2, y: currentPosition.y }, // left\r\n\t\t{ x: currentPosition.x, y: currentPosition.y - 2 }, // top\r\n\t\t{ x: currentPosition.x + 2, y: currentPosition.y }, // right\r\n\t\t{ x: currentPosition.x, y: currentPosition.y + 2 }, // bottom\r\n\t];\r\n\treturn neighbors.filter(neighbor => {\r\n\t\treturn !isOutsideMaze(maze, neighbor) && maze[neighbor.y][neighbor.x] === MazeElement.UNVISITED_EMPTY;\r\n\t});\r\n}\r\n\r\n/**\r\n * Generate random number inside the interval [min, max]\r\n * min and max included\r\n * @param min\r\n * @param max\r\n */\r\nfunction randomInt(min: number, max: number) {\r\n\treturn Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\n/**\r\n * Generate a maze using a depth first search algorthm with backtracking\r\n * https://en.wikipedia.org/wiki/Maze_generation_algorithm\r\n * 1. Choose the initial cell, mark it as visited and push it to the stack\r\n * 2. While the stack is not empty\r\n *      1. Pop a cell from the stack and make it a current cell\r\n *      2. If the current cell has any neighbours which have not been visited\r\n *            1. Push the current cell to the stack\r\n *            2. Choose one of the unvisited neighbours\r\n *            3. Remove the wall between the current cell and the chosen cell\r\n *            4. Mark the chosen cell as visited and push it to the stack\r\n * @param width\r\n * @param height\r\n */\r\nexport function generateMaze(width: number, height: number): MazeElement[][] {\r\n\tconst generatedMaze: MazeElement[][] = new Array<MazeElement[]>(height);\r\n\t// Init maze like:\r\n\t// 111111111\r\n\t// 101010101\r\n\t// 111111111\r\n\t// 101010101\r\n\t// 111111111\r\n\t// 101010101\r\n\t// 111111111\r\n\tfor (let row = 0; row < height; row++) {\r\n\t\tgeneratedMaze[row] = new Array<MazeElement>(width);\r\n\t\tfor (let col = 0; col < width; col++) {\r\n\t\t\tif (row % 2 === 0 || col % 2 === 0) {\r\n\t\t\t\tgeneratedMaze[row][col] = MazeElement.WALL;\r\n\t\t\t} else {\r\n\t\t\t\tgeneratedMaze[row][col] = MazeElement.UNVISITED_EMPTY; // Empty not yet visited, we'll switch this to 0 once we visit the cell during the algorithm\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Remove hedges between empty cells based on maze generation algorithm\r\n\tconst stack: Point[] = [];\r\n\tlet currentPosition: Point = { x: 1, y: 1 };\r\n\tgeneratedMaze[currentPosition.y][currentPosition.x] = 0;\r\n\tstack.push(currentPosition);\r\n\tlet unvisitedNeighbors: Point[];\r\n\twhile (stack.length) {\r\n\t\tcurrentPosition = stack.pop() as Point;\r\n\t\tunvisitedNeighbors = getUnvisitedNeighbors(generatedMaze, currentPosition);\r\n\t\tif (unvisitedNeighbors.length) {\r\n\t\t\tstack.push(currentPosition);\r\n\t\t\tconst unvisitedNeighbor = unvisitedNeighbors[randomInt(0, unvisitedNeighbors.length - 1)];\r\n\t\t\t// Remove hedge\r\n\t\t\tgeneratedMaze[(unvisitedNeighbor.y + currentPosition.y) / 2][(unvisitedNeighbor.x + currentPosition.x) / 2] = 0;\r\n\t\t\t// Mark the neighbor as visited\r\n\t\t\tgeneratedMaze[unvisitedNeighbor.y][unvisitedNeighbor.x] = 0;\r\n\t\t\tstack.push(unvisitedNeighbor);\r\n\t\t}\r\n\t}\r\n\r\n\t// Set start and endpoint\r\n\tgeneratedMaze[1][1] = MazeElement.PLAYER;\r\n\tgeneratedMaze[height - 2][width - 2] = MazeElement.END;\r\n\r\n\treturn generatedMaze;\r\n}\r\n","import { ScreenIoOperations, MazeElement, Point, Quadrant } from './types';\nimport { clampDeg, cos, generateMaze, getSquareDistance, isOutsideMaze, sin, tan, trace } from './utils';\n\nconst mazeWidth = 10;\nconst mazeHeight = 6;\nconst screenWidth = 240;\nconst screenHeight = 160;\nconst playerX = 1.5;\nconst playerY = 1.5;\nconst viewAngleWidth = 70;\nconst angleStep = 7;\nconst playerStepSize = 0.1;\nconst mazeHorCells = mazeWidth * 2 + 1;\nconst mazeVerCells = mazeHeight * 2 + 1;\nconst SKIP_RENDER_RAYS = 1; // 1 => renders all 240 rays, 8 => renders only 240/8 rays\n\n// printFreeSpace('before maze');\nconst maze: MazeElement[][] = generateMaze(mazeHorCells, mazeVerCells);\n// printFreeSpace('after maze');\n// let maze: MazeElement[][] = [\n// \t[1, 1, 1, 1, 1, 1, 1],\n// \t[1, 0, 0, 0, 1, 0, 1],\n// \t[1, 0, 1, 0, 0, 0, 1],\n// \t[1, 0, 1, 0, 1, 0, 1],\n// \t[1, 2, 1, 0, 1, 3, 1],\n// \t[1, 1, 1, 1, 1, 1, 1]\n// ];\n\nconst playerAngle: number = (maze[1][2] === MazeElement.WALL ? 90 : 0);\n\n// Game variables\nconst gameVars = {\n\tmazeWidth,\n\tmazeHeight,\n\tscreenWidth,\n\tscreenHeight,\n\tviewAngleWidth,\n\tangleStep,\n\tplayerStepSize,\n\n\t// Computed values\n\tmazeHorCells,\n\tmazeVerCells,\n\tplayerX,\n\tplayerY,\n\tmaze,\n\t// point te player towards the hallway instead of towards a wall\n\t// Checks if the cell to the right of the player is a wall, if so, point the player down (90), else to the right (0)\n\tplayerAngle,\n\n\tstartGame: (screenIo: ScreenIoOperations) => {\n\t},\n\tstopGame: () => {\n\t},\n};\n\nlet running = true;\n\n\n// } else {\n// \tglobals = {\n// \t\tBangle: Bangle,\n// \t\tg: g,\n// \t\tBTNU: BTN1,\n// \t\tBTND: BTN2,\n// \t\tBTNL: BTN4,\n// \t\tBTNR: BTN5,\n// \t};\n// }\n\nfunction startGame(screenIo: ScreenIoOperations) {\n\trunning = true;\n\tonFrame(screenIo);\n}\n\nfunction stopGame() {\n\trunning = false;\n\t// globals.g.clear();\n\t// globals.g.drawString('Game Over!', 120, (gameVariables.screenHeight - 6) / 2);\n\t// globals.g.flip();\n}\n\n/**\n * https://www.permadi.com/tutorial/raycast/rayc7.html\n */\nfunction getCollisionDistance(viewAngle: number, outerRay: boolean, debugOperations: ScreenIoOperations): Point {\n\t// printFreeSpace('before getCollisionDistance');\n\tconst quadrant: Quadrant = Math.floor(viewAngle / 90);\n\n\tlet horCollision: Point | undefined; // first intersection with a wall\n\tlet vertCollision: Point | undefined; // first intersection with a wall\n\tlet intersectionOffset: number = 0; // number of intersections to skip since the ones before were not an intersection with a wall\n\tlet initialHorIntersectionX: number | undefined; // first intersection with horizontal gridline\n\tlet initialHorIntersectionY: number | undefined;\n\tlet initialVertIntersectionX: number | undefined; // first intersection with vertical gridline\n\tlet initialVertIntersectionY: number | undefined;\n\tlet horizontalOffsetX: number | undefined; // distance between horizontal intersections\n\tlet horizontalOffsetY: number | undefined;\n\tlet verticalOffsetX: number | undefined; // distance between vertical intersections\n\tlet verticalOffsetY: number | undefined;\n\tlet isFacingUp: boolean;\n\tlet isFacingRight: boolean;\n\tlet horIntersectionX: number;\n\tlet horIntersectionY: number;\n\tlet horGridLocation: Point;\n\tlet vertIntersectionX: number;\n\tlet vertIntersectionY: number;\n\tlet vertGridLocation: Point;\n\n\ttrace('01 collision start hor');\n\twhile (!horCollision || !vertCollision) {\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\t// horizontal intersection\n\t\tif (!horCollision) {\n\t\t\tif (!initialHorIntersectionX) {\n\t\t\t\tif (isFacingUp) {\n\t\t\t\t\tinitialHorIntersectionY = Math.floor(gameVars.playerY);\n\t\t\t\t} else {\n\t\t\t\t\tinitialHorIntersectionY = Math.floor(gameVars.playerY) + 1;\n\t\t\t\t}\n\t\t\t\tinitialHorIntersectionX = gameVars.playerX - (gameVars.playerY - initialHorIntersectionY) / tan(viewAngle);\n\t\t\t}\n\n\t\t\ttrace('02 after hor intersect');\n\t\t\tif (intersectionOffset !== 0 && !horizontalOffsetX) {\n\t\t\t\tif (isFacingUp) {\n\t\t\t\t\thorizontalOffsetY = -1;\n\t\t\t\t} else {\n\t\t\t\t\thorizontalOffsetY = 1;\n\t\t\t\t}\n\t\t\t\thorizontalOffsetX = 1 / tan(viewAngle);\n\t\t\t}\n\t\t\ttrace('03 after hor offset');\n\n\t\t\thorIntersectionX = initialHorIntersectionX + (horizontalOffsetX || 0) * intersectionOffset * (isFacingUp ? -1 : 1);\n\t\t\thorIntersectionY = initialHorIntersectionY as number + (horizontalOffsetY || 0) * intersectionOffset;\n\t\t\thorGridLocation = {\n\t\t\t\tx: Math.floor(horIntersectionX),\n\t\t\t\ty: Math.floor(horIntersectionY) + (isFacingUp ? -1 : 0),\n\t\t\t};\n\n\t\t\ttrace('04 after hor grid location');\n\t\t\tif (isOutsideMaze(maze, horGridLocation) || maze[horGridLocation.y][horGridLocation.x] === MazeElement.WALL) {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(horIntersectionX, horIntersectionY);\n\t\t\t\t}\n\t\t\t\thorCollision = { x: horIntersectionX, y: horIntersectionY };\n\t\t\t} else {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(horIntersectionX, horIntersectionY, '#FF0000');\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttrace('05 after hor found location');\n\t\t}\n\n\t\t// Vertical intersection\n\t\ttrace('06 collision start vert');\n\t\tisFacingRight = quadrant === Quadrant.BottomRight || quadrant === Quadrant.TopRight;\n\n\t\tif (!vertCollision) {\n\t\t\tif (!initialVertIntersectionX) {\n\t\t\t\tif (isFacingRight) {\n\t\t\t\t\tinitialVertIntersectionX = Math.floor(gameVars.playerX) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tinitialVertIntersectionX = Math.floor(gameVars.playerX);\n\t\t\t\t}\n\t\t\t\tinitialVertIntersectionY = gameVars.playerY - (gameVars.playerX - initialVertIntersectionX) * tan(viewAngle);\n\t\t\t}\n\t\t\ttrace('07 after vert intersect');\n\t\t\tif (intersectionOffset !== 0 && !verticalOffsetX) {\n\t\t\t\tverticalOffsetX = isFacingRight ? 1 : -1;\n\t\t\t\tverticalOffsetY = Math.abs(tan(viewAngle)) * (isFacingUp ? -1 : 1);\n\t\t\t}\n\t\t\ttrace('08 after vert offset');\n\n\t\t\tvertIntersectionX = initialVertIntersectionX + (verticalOffsetX || 0) * intersectionOffset;\n\t\t\tvertIntersectionY = initialVertIntersectionY as number + (verticalOffsetY || 0) * intersectionOffset;\n\t\t\tvertGridLocation = {\n\t\t\t\tx: Math.floor(vertIntersectionX) + (isFacingRight ? 0 : -1),\n\t\t\t\ty: Math.floor(vertIntersectionY),\n\t\t\t};\n\t\t\ttrace('09 after vert grid location');\n\t\t\tif (isOutsideMaze(maze, vertGridLocation) || maze[vertGridLocation.y][vertGridLocation.x] === MazeElement.WALL) {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(vertIntersectionX, vertIntersectionY);\n\t\t\t\t}\n\t\t\t\tvertCollision = { x: vertIntersectionX, y: vertIntersectionY };\n\t\t\t} else {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(vertIntersectionX, vertIntersectionY, '#FF0000');\n\t\t\t\t}\n\t\t\t}\n\t\t\ttrace('10 after vert found location');\n\t\t}\n\t\tintersectionOffset++;\n\t}\n\ttrace('11 after intersection found location');\n\tconst horDistance = getSquareDistance(gameVars.playerX, gameVars.playerY, horCollision.x, horCollision.y);\n\tconst vertDistance = getSquareDistance(gameVars.playerX, gameVars.playerY, vertCollision.x, vertCollision.y);\n\tconst closestCollision: Point = horDistance < vertDistance ? horCollision : vertCollision;\n\tif (outerRay) {\n\t\tdebugOperations.drawDebugPixel(closestCollision.x, closestCollision.y, '#00FF00');\n\t}\n\tdebugOperations.drawDebugLine(gameVars.playerX, gameVars.playerY, closestCollision.x, closestCollision.y);\n\n\tif (!closestCollision) {\n\t\tthrow new Error('intersection is null');\n\t}\n\n\t// printFreeSpace('after getCollisionDistance');\n\ttrace('12 return intersection');\n\treturn closestCollision;\n}\n\ninterface CollisionInfo {\n\tangle: number;\n\tcollision: Point;\n\tdistance: number;\n\tshouldDrawWall: boolean;\n}\n\nfunction drawWalls(screenIo: ScreenIoOperations) {\n\t// console.log('--------------------------');\n\tscreenIo.drawDebugGrid(maze);\n\n\t// console.log('player angle: ', playerAngle);\n\n\tconst startAngle = clampDeg(gameVars.playerAngle - gameVars.viewAngleWidth / 2);\n\tconst raytraceStepAngle = gameVars.viewAngleWidth / gameVars.screenWidth;\n\tconst anglesCollisionsAndDistances: CollisionInfo[] = [];\n\tfor (let i = 0; i < gameVars.screenWidth; i += SKIP_RENDER_RAYS) {\n\t\tconst viewAngle = clampDeg(startAngle + raytraceStepAngle * i);\n\t\tconst collision: Point = getCollisionDistance(viewAngle, i === 0 || i >= gameVars.screenWidth - 1, screenIo);\n\t\tconst directDistance = Math.sqrt(getSquareDistance(gameVars.playerX, gameVars.playerY, collision.x, collision.y));\n\t\tconst perpendicularDistance = directDistance * cos(clampDeg(viewAngle - gameVars.playerAngle));\n\n\t\tanglesCollisionsAndDistances.push({\n\t\t\tangle: viewAngle,\n\t\t\tcollision,\n\t\t\tdistance: perpendicularDistance,\n\t\t\tshouldDrawWall: false,\n\t\t});\n\n\t\t// let wallHeight = gameVars.screenHeight / perpendicularDistance;\n\t\t// screenIo.drawPixel(i, Math.round((gameVars.screenHeight - wallHeight) / 2));\n\t\t// screenIo.drawPixel(i, Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t}\n\n\t// Identify which rays should also draw a vertical line to identify corners\n\t// Find unique intersection point in the maze which are closest to each collision\n\tconst intersectionPoints: { [coord: string]: Point } = {};\n\tanglesCollisionsAndDistances.forEach(angCollDis => {\n\t\tconst intersectionX = Math.round(angCollDis.collision.x);\n\t\tconst intersectionY = Math.round(angCollDis.collision.y);\n\t\tintersectionPoints[intersectionX + ';' + intersectionY] = { x: intersectionX, y: intersectionY };\n\t});\n\n\t// Determines if we should draw a vertical wall line for the given intersections at the center of these 4 maze cells:\n\t// +-----+\n\t// |0 |1 |\n\t// +-----+\n\t// |2 |3 |\n\t// +-----+\n\t//\n\t// eg: 1000 => should draw a wall at the X\n\t// +--+--+\n\t// |W |  |\n\t// +--X--+\n\t// |  |  |\n\t// +--+--+\n\t//\n\t// eg: 1010 => should not draw a wall at the X since the wall is smoothly running from top to bottom across the intersection\n\t// +--+--+\n\t// |W |  |\n\t// +--X--+\n\t// |W |  |\n\t// +--+--+\n\t//\n\t// We can assume the X location is always visible from the user's perspective\n\tlet CORNERS: { [cornerKey: string]: boolean } = {\n\t\t'0000': false,\n\t\t'0001': true,\n\t\t'0010': true,\n\t\t'0011': false,\n\t\t'0100': true,\n\t\t'0101': false,\n\t\t'0110': false,\n\t\t'0111': true,\n\t\t'1000': true,\n\t\t'1001': true,\n\t\t'1010': false,\n\t\t'1011': true,\n\t\t'1100': false,\n\t\t'1101': true,\n\t\t'1110': true,\n\t\t'1111': false,\n\t};\n\t// printFreeSpace('after corners');\n\n\t// Identify if the intersection should cause a wall line to be displayed or if it is part of a straight wall\n\tconst cornerIntersectionPoints: Point[] = [];\n\tObject.keys(intersectionPoints).forEach(intersectionKey => {\n\t\tconst intersection = intersectionPoints[intersectionKey];\n\t\tconst topLeftCell = maze[intersection.y - 1][intersection.x - 1];\n\t\tconst topRightCell = maze[intersection.y - 1][intersection.x];\n\t\tconst bottomLeftCell = maze[intersection.y][intersection.x - 1];\n\t\tconst bottomRightCell = maze[intersection.y][intersection.x];\n\n\t\t// Generate corner key: eg: 1100 or 1010\n\t\tconst cornerKey: string =\n\t\t\t(topLeftCell === MazeElement.WALL ? '1' : '0') +\n\t\t\t(topRightCell === MazeElement.WALL ? '1' : '0') +\n\t\t\t(bottomLeftCell === MazeElement.WALL ? '1' : '0') +\n\t\t\t(bottomRightCell === MazeElement.WALL ? '1' : '0');\n\t\tconst shouldDrawWall = CORNERS[cornerKey];\n\t\tif (shouldDrawWall) {\n\t\t\tcornerIntersectionPoints.push(intersection);\n\t\t}\n\t});\n\tCORNERS = {};\n\n\t// Find the closest collision to each corner intersection\n\tcornerIntersectionPoints.forEach(intersection => {\n\t\tlet shortestDistance = 100000;\n\t\tlet closestCollisionIndex = 0;\n\t\tanglesCollisionsAndDistances.forEach((collisionInfo: CollisionInfo, index: number) => {\n\t\t\tconst distance = Math.abs(intersection.x - collisionInfo.collision.x) + Math.abs(intersection.y - collisionInfo.collision.y);\n\t\t\tif (distance < shortestDistance) {\n\t\t\t\tclosestCollisionIndex = index;\n\t\t\t\tshortestDistance = distance;\n\t\t\t}\n\t\t});\n\t\tanglesCollisionsAndDistances[closestCollisionIndex].shouldDrawWall = true;\n\t});\n\n\t// Draw the walls\n\tanglesCollisionsAndDistances.forEach((collisionInfo: CollisionInfo, index: number) => {\n\t\tlet wallHeight = gameVars.screenHeight / collisionInfo.distance;\n\n\t\tif (collisionInfo.shouldDrawWall) {\n\t\t\tscreenIo.drawVerticalLine(index, Math.round((gameVars.screenHeight - wallHeight) / 2), Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t\t} else {\n\t\t\tscreenIo.drawPixel(index, Math.round((gameVars.screenHeight - wallHeight) / 2));\n\t\t\tscreenIo.drawPixel(index, Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t\t}\n\t});\n}\n\nfunction isInsideWall(playerX: number, playerY: number) {\n\treturn maze[Math.floor(playerY)][Math.floor(playerX)] === MazeElement.WALL;\n}\n\nfunction movePlayer(deltaX: number, deltaY: number) {\n\t// Try moving in both directions\n\tlet newPlayerX = gameVars.playerX + deltaX;\n\tlet newPlayerY = gameVars.playerY + deltaY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n\t// Try moving in the y direction only\n\tnewPlayerX = gameVars.playerX;\n\tnewPlayerY = gameVars.playerY + deltaY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n\t// Try moving in the x direction only\n\tnewPlayerX = gameVars.playerX + deltaX;\n\tnewPlayerY = gameVars.playerY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n}\n\nlet lastPlayerX: number | undefined;\nlet lastPlayerY: number | undefined;\nlet lastPlayerAngle: number | undefined;\n\nfunction onFrame(screenIo: ScreenIoOperations) {\n\t// let t = getTime();\n\t// let d = (lastFrame===undefined)?0:(t-lastFrame)*20;\n\t// lastFrame = t;\n\n\tif (screenIo.BTN4.read()) {\n\t\tconsole.log('left');\n\t\tgameVars.playerAngle = clampDeg(gameVars.playerAngle - gameVars.angleStep);\n\t}\n\tif (screenIo.BTN5.read()) {\n\t\tconsole.log('right');\n\t\tgameVars.playerAngle = clampDeg(gameVars.playerAngle + gameVars.angleStep);\n\t}\n\tlet quadrant: Quadrant;\n\tlet isFacingUp: boolean;\n\tlet isFacingRight: boolean;\n\tlet playerXDelta: number;\n\tlet playerYDelta: number;\n\tif (screenIo.BTN1.read()) {\n\t\tconsole.log('forward');\n\n\t\tquadrant = Math.floor(gameVars.playerAngle / 90);\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\tisFacingRight = quadrant === Quadrant.TopRight || quadrant === Quadrant.BottomRight;\n\t\tplayerXDelta = Math.abs(cos(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingRight ? 1 : -1);\n\t\tplayerYDelta = Math.abs(sin(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingUp ? -1 : 1);\n\t\tmovePlayer(playerXDelta, playerYDelta);\n\t}\n\tif (screenIo.BTN2.read()) {\n\t\tconsole.log('backward');\n\n\t\tquadrant = Math.floor(gameVars.playerAngle / 90);\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\tisFacingRight = quadrant === Quadrant.TopRight || quadrant === Quadrant.BottomRight;\n\t\tplayerXDelta = Math.abs(cos(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingRight ? -1 : 1);\n\t\tplayerYDelta = Math.abs(sin(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingUp ? 1 : -1);\n\t\tmovePlayer(playerXDelta, playerYDelta);\n\t}\n\n\tif (!running) {\n\t\t// if (BTNA.read()) gameStart();\n\t\treturn;\n\t}\n\n\tif (lastPlayerX !== gameVars.playerX ||\n\t\tlastPlayerY !== gameVars.playerY ||\n\t\tlastPlayerAngle !== gameVars.playerAngle) {\n\t\t// console.log('start draw cycle');\n\t\tscreenIo.clear();\n\t\tdrawWalls(screenIo);\n\t\tscreenIo.flip();\n\t\t// console.log('finished draw cycle');\n\t}\n\n\tlastPlayerX = gameVars.playerX;\n\tlastPlayerY = gameVars.playerY;\n\tlastPlayerAngle = gameVars.playerAngle;\n\tsetTimeout(() => onFrame(screenIo), 50);\n}\n\ngameVars.startGame = startGame;\ngameVars.stopGame = stopGame;\n\nexport const gameVariables = gameVars;\n\n// printFreeSpace('after engine loaded');\n","import { Button, ScreenIoOperations } from './types';\nimport { gameVariables } from './engine';\n// import { printFreeSpace } from './utils';\n\ndeclare const Bangle: any;\ndeclare const g: any;\ndeclare const BTN1: Button;\ndeclare const BTN2: Button;\ndeclare const BTN3: Button;\ndeclare const BTN4: Button;\ndeclare const BTN5: Button;\n\nBangle.setLCDMode('doublebuffered');\n\nfunction drawPixel(x: number, y: number, color?: string) {\n\tg.setPixel(x, y);\n}\n\nfunction drawVerticalLine(x: number, y1: number, y2: number) {\n\tg.drawLine(x, y1, x, y2);\n}\n\nfunction clear() {\n\tg.clear();\n}\n\nfunction flip() {\n\tg.flip();\n}\n\nconst screenIo: ScreenIoOperations = {\n\tBTN1,\n\tBTN2,\n\tBTN3,\n\tBTN4,\n\tBTN5,\n\tdrawPixel,\n\tdrawVerticalLine,\n\tclear,\n\tflip,\n\n\tdrawDebugGrid: () => {},\n\tdrawDebugLine: () => {},\n\tdrawDebugPixel: () => {},\n};\n\ng.setFontAlign(0,-1);\ng.clear();\ng.drawString(\"Press button 2 to start game ==>\",120,(g.getHeight()-6)/2);\ng.flip();\n\nconsole.log('version: ' + (process as any).version);\n// printFreeSpace();\nfunction checkForStart() {\n\tif (BTN2.read()) {\n\t\tconsole.log('starting game');\n\t\tgameVariables.startGame(screenIo);\n\t} else {\n\t\tsetTimeout(checkForStart, 16);\n\t}\n}\n\nconsole.log('starting maze runner');\ncheckForStart();\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n"],"sourceRoot":""}