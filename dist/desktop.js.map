{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utils.ts","webpack:///./src/engine.ts","webpack:///./node_modules/process/browser.js","webpack:///./src/desktop.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","initialTime","Date","getTime","printFreeSpace","time","Math","floor","console","log","process","memory","free","clampDeg","deg","cos","PI","sin","tan","getSquareDistance","x1","y1","x2","y2","isOutsideMaze","maze","location","x","length","y","getUnvisitedNeighbors","currentPosition","filter","neighbor","generateMaze","width","height","generatedMaze","Array","row","col","unvisitedNeighbors","min","max","stack","push","pop","unvisitedNeighbor","random","mazeWidth","mazeHeight","lastPlayerX","lastPlayerY","lastPlayerAngle","playerAngle","gameVars","screenWidth","screenHeight","viewAngleWidth","angleStep","playerStepSize","mazeHorCells","mazeVerCells","playerX","playerY","startGame","screenIo","stopGame","running","getCollisionDistance","viewAngle","outerRay","debugOperations","horCollision","vertCollision","initialHorIntersectionX","initialHorIntersectionY","initialVertIntersectionX","initialVertIntersectionY","horizontalOffsetX","horizontalOffsetY","verticalOffsetX","verticalOffsetY","isFacingUp","isFacingRight","horIntersectionX","horIntersectionY","horGridLocation","vertIntersectionX","vertIntersectionY","vertGridLocation","quadrant","intersectionOffset","drawDebugPixel","abs","closestCollision","drawDebugLine","Error","isInsideWall","movePlayer","deltaX","deltaY","newPlayerX","newPlayerY","onFrame","BTN4","read","BTN5","playerXDelta","playerYDelta","BTN1","BTN2","clear","drawDebugGrid","startAngle","raytraceStepAngle","collision","perpendicularDistance","sqrt","wallHeight","drawPixel","round","drawWalls","flip","setTimeout","gameVariables","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","defaultClearTimeout","runTimeout","fun","e","this","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","concat","drainQueue","timeout","len","run","marker","runClearTimeout","Item","array","noop","nextTick","args","arguments","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","dir","umask","debugCellSize","buttons","code","bangleVar","active","BTN3","prop","forEach","eventType","document","addEventListener","event","keys","which","keyCode","context","drawVerticalLine","fillStyle","fillRect","window","onload","tempContext","canvas","getElementById","getContext","error"],"mappings":"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","file":"desktop.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","import { MazeElement, Point } from './types';\r\n\r\nconst initialTime = new Date().getTime();\r\n\r\nexport function printFreeSpace(name?: string): void {\r\n\tconst time = Math.floor(new Date().getTime() - initialTime);\r\n\tconsole.log((name || 'free memory') + '; ' + time + '; ' + (process as any).memory().free);\r\n}\r\n\r\nexport function clampDeg(deg: number): number {\r\n\treturn (deg + 360) % 360;\r\n}\r\n\r\n\r\n// /**\r\n//  * Generates a lookup table for trigonometric functions\r\n//  * The keys will be the degrees times 10, so we can easily round to 0.1 degree\r\n//  * @param trigonometricFunction\r\n//  */\r\n// function getLookupTable(trigonometricFunction: (rad: number) => number): { [deg: number]: number } {\r\n// \tconst lookup: { [deg: number]: number } = {};\r\n// \tfor (let i = 0; i <= 360; i += 1) {\r\n// \t\tlookup[Math.round(i)] = trigonometricFunction(i / 180 * Math.PI);\r\n// \t}\r\n// \treturn lookup;\r\n// }\r\n//\r\n// const cosLookupTable: { [deg: number]: number } = getLookupTable(Math.cos);\r\n// const sinLookupTable: { [deg: number]: number } = getLookupTable(Math.sin);\r\n// const tanLookupTable: { [deg: number]: number } = getLookupTable(Math.tan);\r\n//\r\n// function lookupAndInterpolate(deg: number, lookupTable: { [deg: number]: number }): number {\r\n// \tconst lowerDeg = Math.floor(deg);\r\n// \tconst upperDeg = Math.ceil(deg + 0.00001);\r\n// \tconst lowerTri = lookupTable[lowerDeg];\r\n// \tconst upperTri = lookupTable[upperDeg];\r\n// \tconst diffDeg = upperDeg - lowerDeg;\r\n// \tconst diffCos = upperTri - lowerTri;\r\n// \treturn lowerTri + Math.abs(deg - lowerDeg) / diffDeg * diffCos;\r\n// }\r\n\r\n// export function cos(deg: number): number {\r\n// \treturn lookupAndInterpolate(deg, cosLookupTable);\r\n// }\r\n//\r\n// export function sin(deg: number): number {\r\n// \treturn lookupAndInterpolate(deg, sinLookupTable);\r\n// }\r\n//\r\n// export function tan(deg: number): number {\r\n// \treturn lookupAndInterpolate(deg, tanLookupTable);\r\n// }\r\n\r\nexport function cos(deg: number): number {\r\n\treturn Math.cos(deg / 180 * Math.PI);\r\n}\r\n\r\nexport function sin(deg: number): number {\r\n\treturn Math.sin(deg / 180 * Math.PI);\r\n}\r\n\r\nexport function tan(deg: number): number {\r\n\treturn Math.tan(deg / 180 * Math.PI);\r\n}\r\n\r\nexport function getSquareDistance(x1: number, y1: number, x2: number, y2: number) {\r\n\treturn (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n}\r\n\r\nexport function isOutsideMaze(maze: MazeElement[][], location: Point): boolean {\r\n\treturn !(location.x >= 0 && location.x < maze[0].length && location.y >= 0 && location.y < maze.length);\r\n}\r\n\r\nfunction getUnvisitedNeighbors(maze: MazeElement[][], currentPosition: Point): Point[] {\r\n\tconst neighbors: Point[] = [\r\n\t\t{ x: currentPosition.x - 2, y: currentPosition.y }, // left\r\n\t\t{ x: currentPosition.x, y: currentPosition.y - 2 }, // top\r\n\t\t{ x: currentPosition.x + 2, y: currentPosition.y }, // right\r\n\t\t{ x: currentPosition.x, y: currentPosition.y + 2 }, // bottom\r\n\t];\r\n\treturn neighbors.filter(neighbor => {\r\n\t\treturn !isOutsideMaze(maze, neighbor) && maze[neighbor.y][neighbor.x] === MazeElement.UNVISITED_EMPTY;\r\n\t});\r\n}\r\n\r\n/**\r\n * Generate random number inside the interval [min, max]\r\n * min and max included\r\n * @param min\r\n * @param max\r\n */\r\nfunction randomInt(min: number, max: number) {\r\n\treturn Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\n/**\r\n * Generate a maze using a depth first search algorthm with backtracking\r\n * https://en.wikipedia.org/wiki/Maze_generation_algorithm\r\n * 1. Choose the initial cell, mark it as visited and push it to the stack\r\n * 2. While the stack is not empty\r\n *      1. Pop a cell from the stack and make it a current cell\r\n *      2. If the current cell has any neighbours which have not been visited\r\n *            1. Push the current cell to the stack\r\n *            2. Choose one of the unvisited neighbours\r\n *            3. Remove the wall between the current cell and the chosen cell\r\n *            4. Mark the chosen cell as visited and push it to the stack\r\n * @param width\r\n * @param height\r\n */\r\nexport function generateMaze(width: number, height: number): MazeElement[][] {\r\n\tconst generatedMaze: MazeElement[][] = new Array<MazeElement[]>(height);\r\n\t// Init maze like:\r\n\t// 111111111\r\n\t// 101010101\r\n\t// 111111111\r\n\t// 101010101\r\n\t// 111111111\r\n\t// 101010101\r\n\t// 111111111\r\n\tfor (let row = 0; row < height; row++) {\r\n\t\tgeneratedMaze[row] = new Array<MazeElement>(width);\r\n\t\tfor (let col = 0; col < width; col++) {\r\n\t\t\tif (row % 2 === 0 || col % 2 === 0) {\r\n\t\t\t\tgeneratedMaze[row][col] = MazeElement.WALL;\r\n\t\t\t} else {\r\n\t\t\t\tgeneratedMaze[row][col] = MazeElement.UNVISITED_EMPTY; // Empty not yet visited, we'll switch this to 0 once we visit the cell during the algorithm\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Remove hedges between empty cells based on maze generation algorithm\r\n\tconst stack: Point[] = [];\r\n\tlet currentPosition: Point = { x: 1, y: 1 };\r\n\tgeneratedMaze[currentPosition.y][currentPosition.x] = 0;\r\n\tstack.push(currentPosition);\r\n\tlet unvisitedNeighbors: Point[];\r\n\twhile (stack.length) {\r\n\t\tcurrentPosition = stack.pop() as Point;\r\n\t\tunvisitedNeighbors = getUnvisitedNeighbors(generatedMaze, currentPosition);\r\n\t\tif (unvisitedNeighbors.length) {\r\n\t\t\tstack.push(currentPosition);\r\n\t\t\tconst unvisitedNeighbor = unvisitedNeighbors[randomInt(0, unvisitedNeighbors.length - 1)];\r\n\t\t\t// Remove hedge\r\n\t\t\tgeneratedMaze[(unvisitedNeighbor.y + currentPosition.y) / 2][(unvisitedNeighbor.x + currentPosition.x) / 2] = 0;\r\n\t\t\t// Mark the neighbor as visited\r\n\t\t\tgeneratedMaze[unvisitedNeighbor.y][unvisitedNeighbor.x] = 0;\r\n\t\t\tstack.push(unvisitedNeighbor);\r\n\t\t}\r\n\t}\r\n\r\n\t// Set start and endpoint\r\n\tgeneratedMaze[1][1] = MazeElement.PLAYER;\r\n\tgeneratedMaze[height - 2][width - 2] = MazeElement.END;\r\n\r\n\treturn generatedMaze;\r\n}\r\n","import { ScreenIoOperations, MazeElement, Point, Quadrant } from './types';\nimport { clampDeg, cos, generateMaze, getSquareDistance, isOutsideMaze, printFreeSpace, sin, tan } from './utils';\n\nconst mazeWidth = 3;\nconst mazeHeight = 3;\nconst screenWidth = 240;\nconst screenHeight = 160;\nconst playerX = 1.5;\nconst playerY = 1.5;\nconst viewAngleWidth = 70;\nconst angleStep = 7;\nconst playerStepSize = 0.1;\nconst mazeHorCells = mazeWidth * 2 + 1;\nconst mazeVerCells = mazeHeight * 2 + 1;\n\nprintFreeSpace('before maze');\nconst maze: MazeElement[][] = generateMaze(mazeHorCells, mazeVerCells);\nprintFreeSpace('after maze');\n// let maze: MazeElement[][] = [\n// \t[1, 1, 1, 1, 1, 1, 1],\n// \t[1, 0, 0, 0, 1, 0, 1],\n// \t[1, 0, 1, 0, 0, 0, 1],\n// \t[1, 0, 1, 0, 1, 0, 1],\n// \t[1, 2, 1, 0, 1, 3, 1],\n// \t[1, 1, 1, 1, 1, 1, 1]\n// ];\n\nconst playerAngle: number = (maze[1][2] === MazeElement.WALL ? 90 : 0);\n\n// Game variables\nconst gameVars = {\n\tmazeWidth,\n\tmazeHeight,\n\tscreenWidth,\n\tscreenHeight,\n\tviewAngleWidth,\n\tangleStep,\n\tplayerStepSize,\n\n\t// Computed values\n\tmazeHorCells,\n\tmazeVerCells,\n\tplayerX,\n\tplayerY,\n\tmaze,\n\t// point te player towards the hallway instead of towards a wall\n\t// Checks if the cell to the right of the player is a wall, if so, point the player down (90), else to the right (0)\n\tplayerAngle,\n\n\tstartGame: (screenIo: ScreenIoOperations) => {\n\t},\n\tstopGame: () => {\n\t},\n};\n\nlet running = true;\n\n\n// } else {\n// \tglobals = {\n// \t\tBangle: Bangle,\n// \t\tg: g,\n// \t\tBTNU: BTN1,\n// \t\tBTND: BTN2,\n// \t\tBTNL: BTN4,\n// \t\tBTNR: BTN5,\n// \t};\n// }\n\nfunction startGame(screenIo: ScreenIoOperations) {\n\trunning = true;\n\tonFrame(screenIo);\n}\n\nfunction stopGame() {\n\trunning = false;\n\t// globals.g.clear();\n\t// globals.g.drawString('Game Over!', 120, (gameVariables.screenHeight - 6) / 2);\n\t// globals.g.flip();\n}\n\n/**\n * https://www.permadi.com/tutorial/raycast/rayc7.html\n */\nfunction getCollisionDistance(viewAngle: number, outerRay: boolean, debugOperations: ScreenIoOperations): Point {\n\t// printFreeSpace('before getCollisionDistance');\n\tconst quadrant: Quadrant = Math.floor(viewAngle / 90);\n\n\tlet horCollision: Point | undefined; // first intersection with a wall\n\tlet vertCollision: Point | undefined; // first intersection with a wall\n\tlet intersectionOffset: number = 0; // number of intersections to skip since the ones before were not an intersection with a wall\n\tlet initialHorIntersectionX: number | undefined; // first intersection with horizontal gridline\n\tlet initialHorIntersectionY: number | undefined;\n\tlet initialVertIntersectionX: number | undefined; // first intersection with vertical gridline\n\tlet initialVertIntersectionY: number | undefined;\n\tlet horizontalOffsetX: number | undefined; // distance between horizontal intersections\n\tlet horizontalOffsetY: number | undefined;\n\tlet verticalOffsetX: number | undefined; // distance between vertical intersections\n\tlet verticalOffsetY: number | undefined;\n\tlet isFacingUp: boolean;\n\tlet isFacingRight: boolean;\n\tlet horIntersectionX: number;\n\tlet horIntersectionY: number;\n\tlet horGridLocation: Point;\n\tlet vertIntersectionX: number;\n\tlet vertIntersectionY: number;\n\tlet vertGridLocation: Point;\n\n\twhile (!horCollision || !vertCollision) {\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\t// horizontal intersection\n\t\tif (!horCollision) {\n\t\t\tif (!initialHorIntersectionX) {\n\t\t\t\tif (isFacingUp) {\n\t\t\t\t\tinitialHorIntersectionY = Math.floor(gameVars.playerY);\n\t\t\t\t} else {\n\t\t\t\t\tinitialHorIntersectionY = Math.floor(gameVars.playerY) + 1;\n\t\t\t\t}\n\t\t\t\tinitialHorIntersectionX = gameVars.playerX - (gameVars.playerY - initialHorIntersectionY) / tan(viewAngle);\n\t\t\t}\n\t\t\tif (intersectionOffset !== 0 && !horizontalOffsetX) {\n\t\t\t\tif (isFacingUp) {\n\t\t\t\t\thorizontalOffsetY = -1;\n\t\t\t\t} else {\n\t\t\t\t\thorizontalOffsetY = 1;\n\t\t\t\t}\n\t\t\t\thorizontalOffsetX = 1 / tan(viewAngle);\n\t\t\t}\n\t\t\thorIntersectionX = initialHorIntersectionX + (horizontalOffsetX || 0) * intersectionOffset * (isFacingUp ? -1 : 1);\n\t\t\thorIntersectionY = initialHorIntersectionY as number + (horizontalOffsetY || 0) * intersectionOffset;\n\t\t\thorGridLocation = {\n\t\t\t\tx: Math.floor(horIntersectionX),\n\t\t\t\ty: Math.floor(horIntersectionY) + (isFacingUp ? -1 : 0),\n\t\t\t};\n\t\t\tif (isOutsideMaze(maze, horGridLocation) || maze[horGridLocation.y][horGridLocation.x] === MazeElement.WALL) {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(horIntersectionX, horIntersectionY);\n\t\t\t\t}\n\t\t\t\thorCollision = { x: horIntersectionX, y: horIntersectionY };\n\t\t\t} else {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(horIntersectionX, horIntersectionY, '#FF0000');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Vertical intersection\n\t\tisFacingRight = quadrant === Quadrant.BottomRight || quadrant === Quadrant.TopRight;\n\n\t\tif (!vertCollision) {\n\t\t\tif (!initialVertIntersectionX) {\n\t\t\t\tif (isFacingRight) {\n\t\t\t\t\tinitialVertIntersectionX = Math.floor(gameVars.playerX) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tinitialVertIntersectionX = Math.floor(gameVars.playerX);\n\t\t\t\t}\n\t\t\t\tinitialVertIntersectionY = gameVars.playerY - (gameVars.playerX - initialVertIntersectionX) * tan(viewAngle);\n\t\t\t}\n\t\t\tif (intersectionOffset !== 0 && !verticalOffsetX) {\n\t\t\t\tverticalOffsetX = isFacingRight ? 1 : -1;\n\t\t\t\tverticalOffsetY = Math.abs(tan(viewAngle)) * (isFacingUp ? -1 : 1);\n\t\t\t}\n\n\t\t\tvertIntersectionX = initialVertIntersectionX + (verticalOffsetX || 0) * intersectionOffset;\n\t\t\tvertIntersectionY = initialVertIntersectionY as number + (verticalOffsetY || 0) * intersectionOffset;\n\t\t\tvertGridLocation = {\n\t\t\t\tx: Math.floor(vertIntersectionX) + (isFacingRight ? 0 : -1),\n\t\t\t\ty: Math.floor(vertIntersectionY),\n\t\t\t};\n\t\t\tif (isOutsideMaze(maze, vertGridLocation) || maze[vertGridLocation.y][vertGridLocation.x] === MazeElement.WALL) {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(vertIntersectionX, vertIntersectionY);\n\t\t\t\t}\n\t\t\t\tvertCollision = { x: vertIntersectionX, y: vertIntersectionY };\n\t\t\t} else {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(vertIntersectionX, vertIntersectionY, '#FF0000');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tintersectionOffset++;\n\t}\n\tconst horDistance = getSquareDistance(gameVars.playerX, gameVars.playerY, horCollision.x, horCollision.y);\n\tconst vertDistance = getSquareDistance(gameVars.playerX, gameVars.playerY, vertCollision.x, vertCollision.y);\n\tconst closestCollision: Point = horDistance < vertDistance ? horCollision : vertCollision;\n\tif (outerRay) {\n\t\tdebugOperations.drawDebugPixel(closestCollision.x, closestCollision.y, '#00FF00');\n\t}\n\tdebugOperations.drawDebugLine(gameVars.playerX, gameVars.playerY, closestCollision.x, closestCollision.y);\n\n\tif (!closestCollision) {\n\t\tthrow new Error('intersection is null');\n\t}\n\n\t// printFreeSpace('after getCollisionDistance');\n\treturn closestCollision;\n}\n\ninterface CollisionInfo {\n\tangle: number;\n\tcollision: Point;\n\tdistance: number;\n\tshouldDrawWall: boolean;\n}\n\nfunction drawWalls(screenIo: ScreenIoOperations) {\n\t// console.log('--------------------------');\n\tscreenIo.drawDebugGrid(maze);\n\n\t// console.log('player angle: ', playerAngle);\n\n\tconst startAngle = clampDeg(gameVars.playerAngle - gameVars.viewAngleWidth / 2);\n\tconst raytraceStepAngle = gameVars.viewAngleWidth / gameVars.screenWidth;\n\tconst anglesCollisionsAndDistances: CollisionInfo[] = [];\n\tfor (let i = 0; i < gameVars.screenWidth; i += 1) {\n\t\tconst viewAngle = clampDeg(startAngle + raytraceStepAngle * i);\n\t\tconst collision: Point = getCollisionDistance(viewAngle, i === 0 || i >= gameVars.screenWidth - 1, screenIo);\n\t\tconst directDistance = Math.sqrt(getSquareDistance(gameVars.playerX, gameVars.playerY, collision.x, collision.y));\n\t\tconst perpendicularDistance = directDistance * cos(clampDeg(viewAngle - gameVars.playerAngle));\n\n\t\t// anglesCollisionsAndDistances.push({\n\t\t// \tangle: viewAngle,\n\t\t// \tcollision,\n\t\t// \tdistance: perpendicularDistance,\n\t\t// \tshouldDrawWall: false,\n\t\t// });\n\n\n\t\tlet wallHeight = gameVars.screenHeight / perpendicularDistance;\n\t\tscreenIo.drawPixel(i, Math.round((gameVars.screenHeight - wallHeight) / 2));\n\t\tscreenIo.drawPixel(i, Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t}\n\t//\n\t// // Identify which rays should also draw a vertical line to identify corners\n\t// // Find unique intersection point in the maze which are closest to each collision\n\t// const intersectionPoints: { [coord: string]: Point } = {};\n\t// anglesCollisionsAndDistances.forEach(angCollDis => {\n\t// \tconst intersectionX = Math.round(angCollDis.collision.x);\n\t// \tconst intersectionY = Math.round(angCollDis.collision.y);\n\t// \tintersectionPoints[intersectionX + ';' + intersectionY] = { x: intersectionX, y: intersectionY };\n\t// });\n\t//\n\t// // Determines if we should draw a vertical wall line for the given intersections at the center of these 4 maze cells:\n\t// // +-----+\n\t// // |0 |1 |\n\t// // +-----+\n\t// // |2 |3 |\n\t// // +-----+\n\t// //\n\t// // eg: 1000 => should draw a wall at the X\n\t// // +--+--+\n\t// // |W |  |\n\t// // +--X--+\n\t// // |  |  |\n\t// // +--+--+\n\t// //\n\t// // eg: 1010 => should not draw a wall at the X since the wall is smoothly running from top to bottom across the intersection\n\t// // +--+--+\n\t// // |W |  |\n\t// // +--X--+\n\t// // |W |  |\n\t// // +--+--+\n\t// //\n\t// // We can assume the X location is always visible from the user's perspective\n\t// let CORNERS: { [cornerKey: string]: boolean } = {\n\t// \t'0000': false,\n\t// \t'0001': true,\n\t// \t'0010': true,\n\t// \t'0011': false,\n\t// \t'0100': true,\n\t// \t'0101': false,\n\t// \t'0110': false,\n\t// \t'0111': true,\n\t// \t'1000': true,\n\t// \t'1001': true,\n\t// \t'1010': false,\n\t// \t'1011': true,\n\t// \t'1100': false,\n\t// \t'1101': true,\n\t// \t'1110': true,\n\t// \t'1111': false,\n\t// };\n\t// printFreeSpace('after corners');\n\t//\n\t// // Identify if the intersection should cause a wall line to be displayed or if it is part of a straight wall\n\t// const cornerIntersectionPoints: Point[] = [];\n\t// Object.keys(intersectionPoints).forEach(intersectionKey => {\n\t// \tconst intersection = intersectionPoints[intersectionKey];\n\t// \tconst topLeftCell = maze[intersection.y - 1][intersection.x - 1];\n\t// \tconst topRightCell = maze[intersection.y - 1][intersection.x];\n\t// \tconst bottomLeftCell = maze[intersection.y][intersection.x - 1];\n\t// \tconst bottomRightCell = maze[intersection.y][intersection.x];\n\t//\n\t// \t// Generate corner key: eg: 1100 or 1010\n\t// \tconst cornerKey: string =\n\t// \t\t(topLeftCell === MazeElement.WALL ? '1' : '0') +\n\t// \t\t(topRightCell === MazeElement.WALL ? '1' : '0') +\n\t// \t\t(bottomLeftCell === MazeElement.WALL ? '1' : '0') +\n\t// \t\t(bottomRightCell === MazeElement.WALL ? '1' : '0');\n\t// \tconst shouldDrawWall = CORNERS[cornerKey];\n\t// \tif (shouldDrawWall) {\n\t// \t\tcornerIntersectionPoints.push(intersection);\n\t// \t}\n\t// });\n\t// CORNERS = {};\n\t//\n\t// // Find the closest collision to each corner intersection\n\t// cornerIntersectionPoints.forEach(intersection => {\n\t// \tlet shortestDistance = 100000;\n\t// \tlet closestCollisionIndex = 0;\n\t// \tanglesCollisionsAndDistances.forEach((collisionInfo: CollisionInfo, index: number) => {\n\t// \t\tconst distance = Math.abs(intersection.x - collisionInfo.collision.x) + Math.abs(intersection.y - collisionInfo.collision.y);\n\t// \t\tif (distance < shortestDistance) {\n\t// \t\t\tclosestCollisionIndex = index;\n\t// \t\t\tshortestDistance = distance;\n\t// \t\t}\n\t// \t});\n\t// \tanglesCollisionsAndDistances[closestCollisionIndex].shouldDrawWall = true;\n\t// });\n\t//\n\t// // Draw the walls\n\t// anglesCollisionsAndDistances.forEach((collisionInfo: CollisionInfo, index: number) => {\n\t// \tlet wallHeight = gameVars.screenHeight / collisionInfo.distance;\n\t//\n\t// \tif (collisionInfo.shouldDrawWall) {\n\t// \t\tscreenIo.drawVerticalLine(index, Math.round((gameVars.screenHeight - wallHeight) / 2), Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t// \t} else {\n\t// \t\tscreenIo.drawPixel(index, Math.round((gameVars.screenHeight - wallHeight) / 2));\n\t// \t\tscreenIo.drawPixel(index, Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t// \t}\n\t// });\n}\n\nfunction isInsideWall(playerX: number, playerY: number) {\n\treturn maze[Math.floor(playerY)][Math.floor(playerX)] === MazeElement.WALL;\n}\n\nfunction movePlayer(deltaX: number, deltaY: number) {\n\t// Try moving in both directions\n\tlet newPlayerX = gameVars.playerX + deltaX;\n\tlet newPlayerY = gameVars.playerY + deltaY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n\t// Try moving in the y direction only\n\tnewPlayerX = gameVars.playerX;\n\tnewPlayerY = gameVars.playerY + deltaY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n\t// Try moving in the x direction only\n\tnewPlayerX = gameVars.playerX + deltaX;\n\tnewPlayerY = gameVars.playerY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n}\n\nlet lastPlayerX: number | undefined;\nlet lastPlayerY: number | undefined;\nlet lastPlayerAngle: number | undefined;\n\nfunction onFrame(screenIo: ScreenIoOperations) {\n\t// let t = getTime();\n\t// let d = (lastFrame===undefined)?0:(t-lastFrame)*20;\n\t// lastFrame = t;\n\n\tif (screenIo.BTN4.read()) {\n\t\tconsole.log('left');\n\t\tgameVars.playerAngle = clampDeg(gameVars.playerAngle - gameVars.angleStep);\n\t}\n\tif (screenIo.BTN5.read()) {\n\t\tconsole.log('right');\n\t\tgameVars.playerAngle = clampDeg(gameVars.playerAngle + gameVars.angleStep);\n\t}\n\tlet quadrant: Quadrant;\n\tlet isFacingUp: boolean;\n\tlet isFacingRight: boolean;\n\tlet playerXDelta: number;\n\tlet playerYDelta: number;\n\tif (screenIo.BTN1.read()) {\n\t\tconsole.log('forward');\n\n\t\tquadrant = Math.floor(gameVars.playerAngle / 90);\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\tisFacingRight = quadrant === Quadrant.TopRight || quadrant === Quadrant.BottomRight;\n\t\tplayerXDelta = Math.abs(cos(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingRight ? 1 : -1);\n\t\tplayerYDelta = Math.abs(sin(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingUp ? -1 : 1);\n\t\tmovePlayer(playerXDelta, playerYDelta);\n\t}\n\tif (screenIo.BTN2.read()) {\n\t\tconsole.log('backward');\n\n\t\tquadrant = Math.floor(gameVars.playerAngle / 90);\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\tisFacingRight = quadrant === Quadrant.TopRight || quadrant === Quadrant.BottomRight;\n\t\tplayerXDelta = Math.abs(cos(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingRight ? -1 : 1);\n\t\tplayerYDelta = Math.abs(sin(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingUp ? 1 : -1);\n\t\tmovePlayer(playerXDelta, playerYDelta);\n\t}\n\n\tif (!running) {\n\t\t// if (BTNA.read()) gameStart();\n\t\treturn;\n\t}\n\n\tif (lastPlayerX !== gameVars.playerX ||\n\t\tlastPlayerY !== gameVars.playerY ||\n\t\tlastPlayerAngle !== gameVars.playerAngle) {\n\t\t// console.log('start draw cycle');\n\t\tscreenIo.clear();\n\t\tdrawWalls(screenIo);\n\t\tscreenIo.flip();\n\t\t// console.log('finished draw cycle');\n\t}\n\n\tlastPlayerX = gameVars.playerX;\n\tlastPlayerY = gameVars.playerY;\n\tlastPlayerAngle = gameVars.playerAngle;\n\tsetTimeout(() => onFrame(screenIo), 50);\n}\n\ngameVars.startGame = startGame;\ngameVars.stopGame = stopGame;\n\nexport const gameVariables = gameVars;\n\nprintFreeSpace('after engine loaded');\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import { gameVariables } from './engine';\nimport { ButtonIndex, MazeElement, ScreenIoOperations } from './types';\nimport { clampDeg, cos, sin } from './utils';\n\nconst debugCellSize = 20;\nconst showDebug = false;\n\ninterface ButtonInfo {\n\tname: 'up' | 'down' | 'menu' | 'left' | 'right';\n\tcode: 9 | 37 | 38 | 39 | 40;\n\tbangleVar: ButtonIndex;\n\tactive: boolean;\n}\n\nconst buttons: { [key in ButtonIndex]: ButtonInfo } = {\n\tBTN1: {\n\t\tname: 'up',\n\t\tcode: 38,\n\t\tbangleVar: 'BTN1',\n\t\tactive: false,\n\t},\n\tBTN2: {\n\t\tname: 'down',\n\t\tcode: 40,\n\t\tbangleVar: 'BTN2',\n\t\tactive: false,\n\t},\n\tBTN3: {\n\t\tname: 'menu',\n\t\tcode: 9,\n\t\tbangleVar: 'BTN3',\n\t\tactive: false,\n\t},\n\tBTN4: {\n\t\tname: 'left',\n\t\tcode: 37,\n\t\tbangleVar: 'BTN4',\n\t\tactive: false,\n\t},\n\tBTN5: {\n\t\tname: 'right',\n\t\tcode: 39,\n\t\tbangleVar: 'BTN5',\n\t\tactive: false,\n\t},\n};\n\n[{ prop: 'keyup', active: false }, { prop: 'keydown', active: true }].forEach((eventType) => {\n\tdocument.addEventListener(eventType.prop as 'keyup' | 'keydown', (event: KeyboardEvent) => {\n\t\t(Object.keys(buttons) as ButtonIndex[]).forEach((key: ButtonIndex) => {\n\t\t\tif ((event.which || event.keyCode) === buttons[key].code) {\n\t\t\t\tbuttons[key].active = eventType.active;\n\t\t\t}\n\t\t});\n\t});\n});\n\nfunction clear() {\n\tcontext.fillStyle = '#EEEEEE';\n\tcontext.fillRect(0, 0, gameVariables.screenWidth, gameVariables.screenHeight);\n\tcontext.fillStyle = '#000000';\n}\n\nfunction flip() {\n}\n\nconst screenIo: ScreenIoOperations = {\n\tBTN1: {\n\t\tread: () => buttons.BTN1.active,\n\t},\n\tBTN2: {\n\t\tread: () => buttons.BTN2.active,\n\t},\n\tBTN3: {\n\t\tread: () => buttons.BTN3.active,\n\t},\n\tBTN4: {\n\t\tread: () => buttons.BTN4.active,\n\t},\n\tBTN5: {\n\t\tread: () => buttons.BTN5.active,\n\t},\n\tdrawPixel,\n\tdrawVerticalLine,\n\tclear,\n\tflip,\n\tdrawDebugGrid: showDebug ? drawDebugGrid : () => {},\n\tdrawDebugLine: showDebug ? drawDebugLine : () => {},\n\tdrawDebugPixel: showDebug ? drawDebugPixel : () => {},\n};\n\nlet context: CanvasRenderingContext2D;\nlet contextDebug: CanvasRenderingContext2D;\nwindow.onload = () => {\n\tconst canvas: HTMLCanvasElement | null = document.getElementById('canvas') as HTMLCanvasElement | null;\n\n\tif (canvas) {\n\t\tcanvas.width = gameVariables.screenWidth;\n\t\tcanvas.height = gameVariables.screenHeight;\n\t\tconst tempContext = canvas.getContext('2d');\n\t\tif (tempContext) {\n\t\t\tcontext = tempContext;\n\t\t} else {\n\t\t\tconsole.error('Failed to get the 2d canvas context');\n\t\t}\n\t} else {\n\t\tconsole.error('Failed to find canvas element');\n\t}\n\n\tif (showDebug) {\n\t\tconst canvasDebug: HTMLCanvasElement | null = document.getElementById('canvas-debug') as HTMLCanvasElement | null;\n\t\tif (canvasDebug) {\n\t\t\tcanvasDebug.width = debugWidth;\n\t\t\tcanvasDebug.height = debugHeight;\n\t\t\tconst tempContext = canvasDebug.getContext('2d');\n\t\t\tif (tempContext) {\n\t\t\t\tcontextDebug = tempContext;\n\t\t\t} else {\n\t\t\t\tconsole.error('Failed to get the 2d canvas context for debug');\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.error('Failed to find canvas element for debug');\n\t\t}\n\t}\n\n\tgameVariables.startGame(screenIo);\n\tconsole.log('starting maze runner');\n};\n\nconst debugWidth = gameVariables.mazeHorCells * debugCellSize;\nconst debugHeight = gameVariables.mazeVerCells * debugCellSize;\n\nfunction drawDebugGrid(maze: MazeElement[][]) {\n\tcontextDebug.fillStyle = '#FFFFFF';\n\tcontextDebug.clearRect(0, 0, debugWidth, debugHeight);\n\n\t// draw grid\n\tcontextDebug.strokeStyle = '#000000';\n\tfor (let row = 0; row < maze.length; row++) {\n\t\tfor (let col = 0; col < maze[0].length; col++) {\n\t\t\tconst mazeItem = maze[row][col];\n\t\t\tcontextDebug.strokeStyle = '#333333';\n\t\t\tif (mazeItem === MazeElement.WALL) {\n\t\t\t\tcontextDebug.fillStyle = '#000000';\n\t\t\t} else if (mazeItem === MazeElement.END) {\n\t\t\t\tcontextDebug.fillStyle = '#00FF00';\n\t\t\t} else { // Empty\n\t\t\t\tcontextDebug.fillStyle = '#FFFFFF';\n\t\t\t}\n\t\t\tcontextDebug.fillRect(col * debugCellSize, row * debugCellSize, debugCellSize, debugCellSize);\n\t\t\tcontextDebug.strokeRect(col * debugCellSize, row * debugCellSize, debugCellSize, debugCellSize);\n\t\t}\n\t}\n\n\t// draw player\n\tcontextDebug.fillStyle = '#0000FF';\n\tcontextDebug.fillRect(gameVariables.playerX * debugCellSize - 3, gameVariables.playerY * debugCellSize - 3, 7, 7);\n\n\t// draw viewAngle\n\tcontextDebug.strokeStyle = '#666666';\n\tcontextDebug.beginPath();\n\tcontextDebug.moveTo(gameVariables.playerX * debugCellSize, gameVariables.playerY * debugCellSize);\n\tcontextDebug.lineTo(gameVariables.playerX * debugCellSize + 1000 * cos(clampDeg(gameVariables.playerAngle - gameVariables.viewAngleWidth / 2)), gameVariables.playerY * debugCellSize + 1000 * sin(clampDeg(gameVariables.playerAngle - gameVariables.viewAngleWidth / 2)));\n\tcontextDebug.stroke();\n\tcontextDebug.beginPath();\n\tcontextDebug.moveTo(gameVariables.playerX * debugCellSize, gameVariables.playerY * debugCellSize);\n\tcontextDebug.lineTo(gameVariables.playerX * debugCellSize + 1000 * cos(clampDeg(gameVariables.playerAngle + gameVariables.viewAngleWidth / 2)), gameVariables.playerY * debugCellSize + 1000 * sin(clampDeg(gameVariables.playerAngle + gameVariables.viewAngleWidth / 2)));\n\tcontextDebug.stroke();\n}\n\nfunction drawDebugPixel(x: number, y: number, color: string = '#ff8e00') {\n\tcontextDebug.fillStyle = color;\n\tcontextDebug.fillRect(x * debugCellSize - 1, y * debugCellSize - 1, 3, 3);\n}\n\nfunction drawDebugLine(x1: number, y1: number, x2: number, y2: number, color: string = 'rgba(200, 200, 200, 0.5)') {\n\tcontextDebug.strokeStyle = color;\n\tcontextDebug.beginPath();\n\tcontextDebug.moveTo(x1 * debugCellSize, y1 * debugCellSize);\n\tcontextDebug.lineTo(x2 * debugCellSize, y2 * debugCellSize);\n\tcontextDebug.stroke();\n}\n\nfunction drawPixel(x: number, y: number) {\n\tif (x >= 0 && x < gameVariables.screenWidth && y >= 0 && y < gameVariables.screenHeight) {\n\t\tcontext.fillStyle = '#000000';\n\t\tcontext.fillRect(x, y, 1, 1);\n\t}\n}\n\nfunction drawVerticalLine(x: number, y1: number, y2: number) {\n\tfor (let i = y1; i <= y2; i++) {\n\t\tdrawPixel(x, i);\n\t}\n}\n"],"sourceRoot":""}