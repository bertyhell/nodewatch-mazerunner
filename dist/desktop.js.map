{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utils.ts","webpack:///./src/engine.ts","webpack:///./src/desktop.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Date","getTime","clampDeg","deg","cos","Math","PI","sin","tan","getSquareDistance","x1","y1","x2","y2","isOutsideMaze","maze","location","x","length","y","getUnvisitedNeighbors","currentPosition","filter","neighbor","generateMaze","width","height","generatedMaze","Array","row","col","unvisitedNeighbors","min","max","stack","push","pop","unvisitedNeighbor","floor","random","lastPlayerX","lastPlayerY","lastPlayerAngle","SKIP_RENDER_RAYS","mazeWidth","mazeHeight","playerAngle","gameVars","screenWidth","screenHeight","viewAngleWidth","angleStep","playerStepSize","mazeHorCells","mazeVerCells","playerX","playerY","startGame","screenIo","stopGame","running","getCollisionDistance","viewAngle","outerRay","debugOperations","horCollision","vertCollision","initialHorIntersectionX","initialHorIntersectionY","initialVertIntersectionX","initialVertIntersectionY","horizontalOffsetX","horizontalOffsetY","verticalOffsetX","verticalOffsetY","isFacingUp","isFacingRight","horIntersectionX","horIntersectionY","horGridLocation","vertIntersectionX","vertIntersectionY","vertGridLocation","quadrant","intersectionOffset","drawDebugPixel","abs","closestCollision","drawDebugLine","Error","isInsideWall","movePlayer","deltaX","deltaY","newPlayerX","newPlayerY","onFrame","BTN4","read","console","log","BTN5","playerXDelta","playerYDelta","BTN1","BTN2","clear","drawDebugGrid","startAngle","raytraceStepAngle","collision","perpendicularDistance","sqrt","wallHeight","drawPixel","round","drawWalls","flip","setTimeout","gameVariables","debugCellSize","buttons","code","bangleVar","active","BTN3","prop","forEach","eventType","document","addEventListener","event","keys","which","keyCode","context","drawVerticalLine","fillStyle","fillRect","window","onload","tempContext","canvas","getElementById","getContext","error"],"mappings":"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","file":"desktop.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { MazeElement, Point } from './types';\r\n\r\nconst initialTime = new Date().getTime();\r\n\r\n// export function printFreeSpace(name?: string): void {\r\n// \tif (!(process as any).memory) {\r\n// \t\treturn;\r\n// \t}\r\n// \tconst time = Math.floor(new Date().getTime() - initialTime);\r\n// \tconsole.log((name || 'free memory') + '; ' + time + '; ' + (process as any).memory().free);\r\n// }\r\n\r\nexport function clampDeg(deg: number): number {\r\n\treturn (deg + 360) % 360;\r\n}\r\n\r\n\r\n// /**\r\n//  * Generates a lookup table for trigonometric functions\r\n//  * The keys will be the degrees times 10, so we can easily round to 0.1 degree\r\n//  * @param trigonometricFunction\r\n//  */\r\n// function getLookupTable(trigonometricFunction: (rad: number) => number): { [deg: number]: number } {\r\n// \tconst lookup: { [deg: number]: number } = {};\r\n// \tfor (let i = 0; i <= 360; i += 1) {\r\n// \t\tlookup[Math.round(i)] = trigonometricFunction(i / 180 * Math.PI);\r\n// \t}\r\n// \treturn lookup;\r\n// }\r\n//\r\n// const cosLookupTable: { [deg: number]: number } = getLookupTable(Math.cos);\r\n// const sinLookupTable: { [deg: number]: number } = getLookupTable(Math.sin);\r\n// const tanLookupTable: { [deg: number]: number } = getLookupTable(Math.tan);\r\n//\r\n// function lookupAndInterpolate(deg: number, lookupTable: { [deg: number]: number }): number {\r\n// \tconst lowerDeg = Math.floor(deg);\r\n// \tconst upperDeg = Math.ceil(deg + 0.00001);\r\n// \tconst lowerTri = lookupTable[lowerDeg];\r\n// \tconst upperTri = lookupTable[upperDeg];\r\n// \tconst diffDeg = upperDeg - lowerDeg;\r\n// \tconst diffCos = upperTri - lowerTri;\r\n// \treturn lowerTri + Math.abs(deg - lowerDeg) / diffDeg * diffCos;\r\n// }\r\n\r\n// export function cos(deg: number): number {\r\n// \treturn lookupAndInterpolate(deg, cosLookupTable);\r\n// }\r\n//\r\n// export function sin(deg: number): number {\r\n// \treturn lookupAndInterpolate(deg, sinLookupTable);\r\n// }\r\n//\r\n// export function tan(deg: number): number {\r\n// \treturn lookupAndInterpolate(deg, tanLookupTable);\r\n// }\r\n\r\nexport function cos(deg: number): number {\r\n\treturn Math.cos(deg / 180 * Math.PI);\r\n}\r\n\r\nexport function sin(deg: number): number {\r\n\treturn Math.sin(deg / 180 * Math.PI);\r\n}\r\n\r\nexport function tan(deg: number): number {\r\n\treturn Math.tan(deg / 180 * Math.PI);\r\n}\r\n\r\nexport function getSquareDistance(x1: number, y1: number, x2: number, y2: number) {\r\n\treturn (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\r\n}\r\n\r\nexport function isOutsideMaze(maze: MazeElement[][], location: Point): boolean {\r\n\treturn !(location.x >= 0 && location.x < maze[0].length && location.y >= 0 && location.y < maze.length);\r\n}\r\n\r\nfunction getUnvisitedNeighbors(maze: MazeElement[][], currentPosition: Point): Point[] {\r\n\tconst neighbors: Point[] = [\r\n\t\t{ x: currentPosition.x - 2, y: currentPosition.y }, // left\r\n\t\t{ x: currentPosition.x, y: currentPosition.y - 2 }, // top\r\n\t\t{ x: currentPosition.x + 2, y: currentPosition.y }, // right\r\n\t\t{ x: currentPosition.x, y: currentPosition.y + 2 }, // bottom\r\n\t];\r\n\treturn neighbors.filter(neighbor => {\r\n\t\treturn !isOutsideMaze(maze, neighbor) && maze[neighbor.y][neighbor.x] === MazeElement.UNVISITED_EMPTY;\r\n\t});\r\n}\r\n\r\n/**\r\n * Generate random number inside the interval [min, max]\r\n * min and max included\r\n * @param min\r\n * @param max\r\n */\r\nfunction randomInt(min: number, max: number) {\r\n\treturn Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\n/**\r\n * Generate a maze using a depth first search algorthm with backtracking\r\n * https://en.wikipedia.org/wiki/Maze_generation_algorithm\r\n * 1. Choose the initial cell, mark it as visited and push it to the stack\r\n * 2. While the stack is not empty\r\n *      1. Pop a cell from the stack and make it a current cell\r\n *      2. If the current cell has any neighbours which have not been visited\r\n *            1. Push the current cell to the stack\r\n *            2. Choose one of the unvisited neighbours\r\n *            3. Remove the wall between the current cell and the chosen cell\r\n *            4. Mark the chosen cell as visited and push it to the stack\r\n * @param width\r\n * @param height\r\n */\r\nexport function generateMaze(width: number, height: number): MazeElement[][] {\r\n\tconst generatedMaze: MazeElement[][] = new Array<MazeElement[]>(height);\r\n\t// Init maze like:\r\n\t// 111111111\r\n\t// 101010101\r\n\t// 111111111\r\n\t// 101010101\r\n\t// 111111111\r\n\t// 101010101\r\n\t// 111111111\r\n\tfor (let row = 0; row < height; row++) {\r\n\t\tgeneratedMaze[row] = new Array<MazeElement>(width);\r\n\t\tfor (let col = 0; col < width; col++) {\r\n\t\t\tif (row % 2 === 0 || col % 2 === 0) {\r\n\t\t\t\tgeneratedMaze[row][col] = MazeElement.WALL;\r\n\t\t\t} else {\r\n\t\t\t\tgeneratedMaze[row][col] = MazeElement.UNVISITED_EMPTY; // Empty not yet visited, we'll switch this to 0 once we visit the cell during the algorithm\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// Remove hedges between empty cells based on maze generation algorithm\r\n\tconst stack: Point[] = [];\r\n\tlet currentPosition: Point = { x: 1, y: 1 };\r\n\tgeneratedMaze[currentPosition.y][currentPosition.x] = 0;\r\n\tstack.push(currentPosition);\r\n\tlet unvisitedNeighbors: Point[];\r\n\twhile (stack.length) {\r\n\t\tcurrentPosition = stack.pop() as Point;\r\n\t\tunvisitedNeighbors = getUnvisitedNeighbors(generatedMaze, currentPosition);\r\n\t\tif (unvisitedNeighbors.length) {\r\n\t\t\tstack.push(currentPosition);\r\n\t\t\tconst unvisitedNeighbor = unvisitedNeighbors[randomInt(0, unvisitedNeighbors.length - 1)];\r\n\t\t\t// Remove hedge\r\n\t\t\tgeneratedMaze[(unvisitedNeighbor.y + currentPosition.y) / 2][(unvisitedNeighbor.x + currentPosition.x) / 2] = 0;\r\n\t\t\t// Mark the neighbor as visited\r\n\t\t\tgeneratedMaze[unvisitedNeighbor.y][unvisitedNeighbor.x] = 0;\r\n\t\t\tstack.push(unvisitedNeighbor);\r\n\t\t}\r\n\t}\r\n\r\n\t// Set start and endpoint\r\n\tgeneratedMaze[1][1] = MazeElement.PLAYER;\r\n\tgeneratedMaze[height - 2][width - 2] = MazeElement.END;\r\n\r\n\treturn generatedMaze;\r\n}\r\n","import { ScreenIoOperations, MazeElement, Point, Quadrant } from './types';\nimport { clampDeg, cos, generateMaze, getSquareDistance, isOutsideMaze, sin, tan } from './utils';\n\nconst mazeWidth = 3;\nconst mazeHeight = 3;\nconst screenWidth = 240;\nconst screenHeight = 160;\nconst playerX = 1.5;\nconst playerY = 1.5;\nconst viewAngleWidth = 70;\nconst angleStep = 7;\nconst playerStepSize = 0.1;\nconst mazeHorCells = mazeWidth * 2 + 1;\nconst mazeVerCells = mazeHeight * 2 + 1;\nconst SKIP_RENDER_RAYS = 8; // 1 => renders all 240 rays, 8 => renders only 240/8 rays\n\n// printFreeSpace('before maze');\nconst maze: MazeElement[][] = generateMaze(mazeHorCells, mazeVerCells);\n// printFreeSpace('after maze');\n// let maze: MazeElement[][] = [\n// \t[1, 1, 1, 1, 1, 1, 1],\n// \t[1, 0, 0, 0, 1, 0, 1],\n// \t[1, 0, 1, 0, 0, 0, 1],\n// \t[1, 0, 1, 0, 1, 0, 1],\n// \t[1, 2, 1, 0, 1, 3, 1],\n// \t[1, 1, 1, 1, 1, 1, 1]\n// ];\n\nconst playerAngle: number = (maze[1][2] === MazeElement.WALL ? 90 : 0);\n\n// Game variables\nconst gameVars = {\n\tmazeWidth,\n\tmazeHeight,\n\tscreenWidth,\n\tscreenHeight,\n\tviewAngleWidth,\n\tangleStep,\n\tplayerStepSize,\n\n\t// Computed values\n\tmazeHorCells,\n\tmazeVerCells,\n\tplayerX,\n\tplayerY,\n\tmaze,\n\t// point te player towards the hallway instead of towards a wall\n\t// Checks if the cell to the right of the player is a wall, if so, point the player down (90), else to the right (0)\n\tplayerAngle,\n\n\tstartGame: (screenIo: ScreenIoOperations) => {\n\t},\n\tstopGame: () => {\n\t},\n};\n\nlet running = true;\n\n\n// } else {\n// \tglobals = {\n// \t\tBangle: Bangle,\n// \t\tg: g,\n// \t\tBTNU: BTN1,\n// \t\tBTND: BTN2,\n// \t\tBTNL: BTN4,\n// \t\tBTNR: BTN5,\n// \t};\n// }\n\nfunction startGame(screenIo: ScreenIoOperations) {\n\trunning = true;\n\tonFrame(screenIo);\n}\n\nfunction stopGame() {\n\trunning = false;\n\t// globals.g.clear();\n\t// globals.g.drawString('Game Over!', 120, (gameVariables.screenHeight - 6) / 2);\n\t// globals.g.flip();\n}\n\n/**\n * https://www.permadi.com/tutorial/raycast/rayc7.html\n */\nfunction getCollisionDistance(viewAngle: number, outerRay: boolean, debugOperations: ScreenIoOperations): Point {\n\t// printFreeSpace('before getCollisionDistance');\n\tconst quadrant: Quadrant = Math.floor(viewAngle / 90);\n\n\tlet horCollision: Point | undefined; // first intersection with a wall\n\tlet vertCollision: Point | undefined; // first intersection with a wall\n\tlet intersectionOffset: number = 0; // number of intersections to skip since the ones before were not an intersection with a wall\n\tlet initialHorIntersectionX: number | undefined; // first intersection with horizontal gridline\n\tlet initialHorIntersectionY: number | undefined;\n\tlet initialVertIntersectionX: number | undefined; // first intersection with vertical gridline\n\tlet initialVertIntersectionY: number | undefined;\n\tlet horizontalOffsetX: number | undefined; // distance between horizontal intersections\n\tlet horizontalOffsetY: number | undefined;\n\tlet verticalOffsetX: number | undefined; // distance between vertical intersections\n\tlet verticalOffsetY: number | undefined;\n\tlet isFacingUp: boolean;\n\tlet isFacingRight: boolean;\n\tlet horIntersectionX: number;\n\tlet horIntersectionY: number;\n\tlet horGridLocation: Point;\n\tlet vertIntersectionX: number;\n\tlet vertIntersectionY: number;\n\tlet vertGridLocation: Point;\n\n\twhile (!horCollision || !vertCollision) {\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\t// horizontal intersection\n\t\tif (!horCollision) {\n\t\t\tif (!initialHorIntersectionX) {\n\t\t\t\tif (isFacingUp) {\n\t\t\t\t\tinitialHorIntersectionY = Math.floor(gameVars.playerY);\n\t\t\t\t} else {\n\t\t\t\t\tinitialHorIntersectionY = Math.floor(gameVars.playerY) + 1;\n\t\t\t\t}\n\t\t\t\tinitialHorIntersectionX = gameVars.playerX - (gameVars.playerY - initialHorIntersectionY) / tan(viewAngle);\n\t\t\t}\n\t\t\tif (intersectionOffset !== 0 && !horizontalOffsetX) {\n\t\t\t\tif (isFacingUp) {\n\t\t\t\t\thorizontalOffsetY = -1;\n\t\t\t\t} else {\n\t\t\t\t\thorizontalOffsetY = 1;\n\t\t\t\t}\n\t\t\t\thorizontalOffsetX = 1 / tan(viewAngle);\n\t\t\t}\n\t\t\thorIntersectionX = initialHorIntersectionX + (horizontalOffsetX || 0) * intersectionOffset * (isFacingUp ? -1 : 1);\n\t\t\thorIntersectionY = initialHorIntersectionY as number + (horizontalOffsetY || 0) * intersectionOffset;\n\t\t\thorGridLocation = {\n\t\t\t\tx: Math.floor(horIntersectionX),\n\t\t\t\ty: Math.floor(horIntersectionY) + (isFacingUp ? -1 : 0),\n\t\t\t};\n\t\t\tif (isOutsideMaze(maze, horGridLocation) || maze[horGridLocation.y][horGridLocation.x] === MazeElement.WALL) {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(horIntersectionX, horIntersectionY);\n\t\t\t\t}\n\t\t\t\thorCollision = { x: horIntersectionX, y: horIntersectionY };\n\t\t\t} else {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(horIntersectionX, horIntersectionY, '#FF0000');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Vertical intersection\n\t\tisFacingRight = quadrant === Quadrant.BottomRight || quadrant === Quadrant.TopRight;\n\n\t\tif (!vertCollision) {\n\t\t\tif (!initialVertIntersectionX) {\n\t\t\t\tif (isFacingRight) {\n\t\t\t\t\tinitialVertIntersectionX = Math.floor(gameVars.playerX) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tinitialVertIntersectionX = Math.floor(gameVars.playerX);\n\t\t\t\t}\n\t\t\t\tinitialVertIntersectionY = gameVars.playerY - (gameVars.playerX - initialVertIntersectionX) * tan(viewAngle);\n\t\t\t}\n\t\t\tif (intersectionOffset !== 0 && !verticalOffsetX) {\n\t\t\t\tverticalOffsetX = isFacingRight ? 1 : -1;\n\t\t\t\tverticalOffsetY = Math.abs(tan(viewAngle)) * (isFacingUp ? -1 : 1);\n\t\t\t}\n\n\t\t\tvertIntersectionX = initialVertIntersectionX + (verticalOffsetX || 0) * intersectionOffset;\n\t\t\tvertIntersectionY = initialVertIntersectionY as number + (verticalOffsetY || 0) * intersectionOffset;\n\t\t\tvertGridLocation = {\n\t\t\t\tx: Math.floor(vertIntersectionX) + (isFacingRight ? 0 : -1),\n\t\t\t\ty: Math.floor(vertIntersectionY),\n\t\t\t};\n\t\t\tif (isOutsideMaze(maze, vertGridLocation) || maze[vertGridLocation.y][vertGridLocation.x] === MazeElement.WALL) {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(vertIntersectionX, vertIntersectionY);\n\t\t\t\t}\n\t\t\t\tvertCollision = { x: vertIntersectionX, y: vertIntersectionY };\n\t\t\t} else {\n\t\t\t\tif (outerRay) {\n\t\t\t\t\tdebugOperations.drawDebugPixel(vertIntersectionX, vertIntersectionY, '#FF0000');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tintersectionOffset++;\n\t}\n\tconst horDistance = getSquareDistance(gameVars.playerX, gameVars.playerY, horCollision.x, horCollision.y);\n\tconst vertDistance = getSquareDistance(gameVars.playerX, gameVars.playerY, vertCollision.x, vertCollision.y);\n\tconst closestCollision: Point = horDistance < vertDistance ? horCollision : vertCollision;\n\tif (outerRay) {\n\t\tdebugOperations.drawDebugPixel(closestCollision.x, closestCollision.y, '#00FF00');\n\t}\n\tdebugOperations.drawDebugLine(gameVars.playerX, gameVars.playerY, closestCollision.x, closestCollision.y);\n\n\tif (!closestCollision) {\n\t\tthrow new Error('intersection is null');\n\t}\n\n\t// printFreeSpace('after getCollisionDistance');\n\treturn closestCollision;\n}\n\ninterface CollisionInfo {\n\tangle: number;\n\tcollision: Point;\n\tdistance: number;\n\tshouldDrawWall: boolean;\n}\n\nfunction drawWalls(screenIo: ScreenIoOperations) {\n\t// console.log('--------------------------');\n\tscreenIo.drawDebugGrid(maze);\n\n\t// console.log('player angle: ', playerAngle);\n\n\tconst startAngle = clampDeg(gameVars.playerAngle - gameVars.viewAngleWidth / 2);\n\tconst raytraceStepAngle = gameVars.viewAngleWidth / gameVars.screenWidth;\n\tconst anglesCollisionsAndDistances: CollisionInfo[] = [];\n\tfor (let i = 0; i < gameVars.screenWidth; i += SKIP_RENDER_RAYS) {\n\t\tconst viewAngle = clampDeg(startAngle + raytraceStepAngle * i);\n\t\tconst collision: Point = getCollisionDistance(viewAngle, i === 0 || i >= gameVars.screenWidth - 1, screenIo);\n\t\tconst directDistance = Math.sqrt(getSquareDistance(gameVars.playerX, gameVars.playerY, collision.x, collision.y));\n\t\tconst perpendicularDistance = directDistance * cos(clampDeg(viewAngle - gameVars.playerAngle));\n\n\t\t// anglesCollisionsAndDistances.push({\n\t\t// \tangle: viewAngle,\n\t\t// \tcollision,\n\t\t// \tdistance: perpendicularDistance,\n\t\t// \tshouldDrawWall: false,\n\t\t// });\n\n\n\t\tlet wallHeight = gameVars.screenHeight / perpendicularDistance;\n\t\tscreenIo.drawPixel(i, Math.round((gameVars.screenHeight - wallHeight) / 2));\n\t\tscreenIo.drawPixel(i, Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t}\n\t//\n\t// // Identify which rays should also draw a vertical line to identify corners\n\t// // Find unique intersection point in the maze which are closest to each collision\n\t// const intersectionPoints: { [coord: string]: Point } = {};\n\t// anglesCollisionsAndDistances.forEach(angCollDis => {\n\t// \tconst intersectionX = Math.round(angCollDis.collision.x);\n\t// \tconst intersectionY = Math.round(angCollDis.collision.y);\n\t// \tintersectionPoints[intersectionX + ';' + intersectionY] = { x: intersectionX, y: intersectionY };\n\t// });\n\t//\n\t// // Determines if we should draw a vertical wall line for the given intersections at the center of these 4 maze cells:\n\t// // +-----+\n\t// // |0 |1 |\n\t// // +-----+\n\t// // |2 |3 |\n\t// // +-----+\n\t// //\n\t// // eg: 1000 => should draw a wall at the X\n\t// // +--+--+\n\t// // |W |  |\n\t// // +--X--+\n\t// // |  |  |\n\t// // +--+--+\n\t// //\n\t// // eg: 1010 => should not draw a wall at the X since the wall is smoothly running from top to bottom across the intersection\n\t// // +--+--+\n\t// // |W |  |\n\t// // +--X--+\n\t// // |W |  |\n\t// // +--+--+\n\t// //\n\t// // We can assume the X location is always visible from the user's perspective\n\t// let CORNERS: { [cornerKey: string]: boolean } = {\n\t// \t'0000': false,\n\t// \t'0001': true,\n\t// \t'0010': true,\n\t// \t'0011': false,\n\t// \t'0100': true,\n\t// \t'0101': false,\n\t// \t'0110': false,\n\t// \t'0111': true,\n\t// \t'1000': true,\n\t// \t'1001': true,\n\t// \t'1010': false,\n\t// \t'1011': true,\n\t// \t'1100': false,\n\t// \t'1101': true,\n\t// \t'1110': true,\n\t// \t'1111': false,\n\t// };\n\t// printFreeSpace('after corners');\n\t//\n\t// // Identify if the intersection should cause a wall line to be displayed or if it is part of a straight wall\n\t// const cornerIntersectionPoints: Point[] = [];\n\t// Object.keys(intersectionPoints).forEach(intersectionKey => {\n\t// \tconst intersection = intersectionPoints[intersectionKey];\n\t// \tconst topLeftCell = maze[intersection.y - 1][intersection.x - 1];\n\t// \tconst topRightCell = maze[intersection.y - 1][intersection.x];\n\t// \tconst bottomLeftCell = maze[intersection.y][intersection.x - 1];\n\t// \tconst bottomRightCell = maze[intersection.y][intersection.x];\n\t//\n\t// \t// Generate corner key: eg: 1100 or 1010\n\t// \tconst cornerKey: string =\n\t// \t\t(topLeftCell === MazeElement.WALL ? '1' : '0') +\n\t// \t\t(topRightCell === MazeElement.WALL ? '1' : '0') +\n\t// \t\t(bottomLeftCell === MazeElement.WALL ? '1' : '0') +\n\t// \t\t(bottomRightCell === MazeElement.WALL ? '1' : '0');\n\t// \tconst shouldDrawWall = CORNERS[cornerKey];\n\t// \tif (shouldDrawWall) {\n\t// \t\tcornerIntersectionPoints.push(intersection);\n\t// \t}\n\t// });\n\t// CORNERS = {};\n\t//\n\t// // Find the closest collision to each corner intersection\n\t// cornerIntersectionPoints.forEach(intersection => {\n\t// \tlet shortestDistance = 100000;\n\t// \tlet closestCollisionIndex = 0;\n\t// \tanglesCollisionsAndDistances.forEach((collisionInfo: CollisionInfo, index: number) => {\n\t// \t\tconst distance = Math.abs(intersection.x - collisionInfo.collision.x) + Math.abs(intersection.y - collisionInfo.collision.y);\n\t// \t\tif (distance < shortestDistance) {\n\t// \t\t\tclosestCollisionIndex = index;\n\t// \t\t\tshortestDistance = distance;\n\t// \t\t}\n\t// \t});\n\t// \tanglesCollisionsAndDistances[closestCollisionIndex].shouldDrawWall = true;\n\t// });\n\t//\n\t// // Draw the walls\n\t// anglesCollisionsAndDistances.forEach((collisionInfo: CollisionInfo, index: number) => {\n\t// \tlet wallHeight = gameVars.screenHeight / collisionInfo.distance;\n\t//\n\t// \tif (collisionInfo.shouldDrawWall) {\n\t// \t\tscreenIo.drawVerticalLine(index, Math.round((gameVars.screenHeight - wallHeight) / 2), Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t// \t} else {\n\t// \t\tscreenIo.drawPixel(index, Math.round((gameVars.screenHeight - wallHeight) / 2));\n\t// \t\tscreenIo.drawPixel(index, Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t// \t}\n\t// });\n}\n\nfunction isInsideWall(playerX: number, playerY: number) {\n\treturn maze[Math.floor(playerY)][Math.floor(playerX)] === MazeElement.WALL;\n}\n\nfunction movePlayer(deltaX: number, deltaY: number) {\n\t// Try moving in both directions\n\tlet newPlayerX = gameVars.playerX + deltaX;\n\tlet newPlayerY = gameVars.playerY + deltaY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n\t// Try moving in the y direction only\n\tnewPlayerX = gameVars.playerX;\n\tnewPlayerY = gameVars.playerY + deltaY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n\t// Try moving in the x direction only\n\tnewPlayerX = gameVars.playerX + deltaX;\n\tnewPlayerY = gameVars.playerY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n}\n\nlet lastPlayerX: number | undefined;\nlet lastPlayerY: number | undefined;\nlet lastPlayerAngle: number | undefined;\n\nfunction onFrame(screenIo: ScreenIoOperations) {\n\t// let t = getTime();\n\t// let d = (lastFrame===undefined)?0:(t-lastFrame)*20;\n\t// lastFrame = t;\n\n\tif (screenIo.BTN4.read()) {\n\t\tconsole.log('left');\n\t\tgameVars.playerAngle = clampDeg(gameVars.playerAngle - gameVars.angleStep);\n\t}\n\tif (screenIo.BTN5.read()) {\n\t\tconsole.log('right');\n\t\tgameVars.playerAngle = clampDeg(gameVars.playerAngle + gameVars.angleStep);\n\t}\n\tlet quadrant: Quadrant;\n\tlet isFacingUp: boolean;\n\tlet isFacingRight: boolean;\n\tlet playerXDelta: number;\n\tlet playerYDelta: number;\n\tif (screenIo.BTN1.read()) {\n\t\tconsole.log('forward');\n\n\t\tquadrant = Math.floor(gameVars.playerAngle / 90);\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\tisFacingRight = quadrant === Quadrant.TopRight || quadrant === Quadrant.BottomRight;\n\t\tplayerXDelta = Math.abs(cos(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingRight ? 1 : -1);\n\t\tplayerYDelta = Math.abs(sin(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingUp ? -1 : 1);\n\t\tmovePlayer(playerXDelta, playerYDelta);\n\t}\n\tif (screenIo.BTN2.read()) {\n\t\tconsole.log('backward');\n\n\t\tquadrant = Math.floor(gameVars.playerAngle / 90);\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\tisFacingRight = quadrant === Quadrant.TopRight || quadrant === Quadrant.BottomRight;\n\t\tplayerXDelta = Math.abs(cos(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingRight ? -1 : 1);\n\t\tplayerYDelta = Math.abs(sin(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingUp ? 1 : -1);\n\t\tmovePlayer(playerXDelta, playerYDelta);\n\t}\n\n\tif (!running) {\n\t\t// if (BTNA.read()) gameStart();\n\t\treturn;\n\t}\n\n\tif (lastPlayerX !== gameVars.playerX ||\n\t\tlastPlayerY !== gameVars.playerY ||\n\t\tlastPlayerAngle !== gameVars.playerAngle) {\n\t\t// console.log('start draw cycle');\n\t\tscreenIo.clear();\n\t\tdrawWalls(screenIo);\n\t\tscreenIo.flip();\n\t\t// console.log('finished draw cycle');\n\t}\n\n\tlastPlayerX = gameVars.playerX;\n\tlastPlayerY = gameVars.playerY;\n\tlastPlayerAngle = gameVars.playerAngle;\n\tsetTimeout(() => onFrame(screenIo), 50);\n}\n\ngameVars.startGame = startGame;\ngameVars.stopGame = stopGame;\n\nexport const gameVariables = gameVars;\n\n// printFreeSpace('after engine loaded');\n","import { gameVariables } from './engine';\nimport { ButtonIndex, MazeElement, ScreenIoOperations } from './types';\nimport { clampDeg, cos, sin } from './utils';\n\nconst debugCellSize = 20;\nconst showDebug = false;\n\ninterface ButtonInfo {\n\tname: 'up' | 'down' | 'menu' | 'left' | 'right';\n\tcode: 9 | 37 | 38 | 39 | 40;\n\tbangleVar: ButtonIndex;\n\tactive: boolean;\n}\n\nconst buttons: { [key in ButtonIndex]: ButtonInfo } = {\n\tBTN1: {\n\t\tname: 'up',\n\t\tcode: 38,\n\t\tbangleVar: 'BTN1',\n\t\tactive: false,\n\t},\n\tBTN2: {\n\t\tname: 'down',\n\t\tcode: 40,\n\t\tbangleVar: 'BTN2',\n\t\tactive: false,\n\t},\n\tBTN3: {\n\t\tname: 'menu',\n\t\tcode: 9,\n\t\tbangleVar: 'BTN3',\n\t\tactive: false,\n\t},\n\tBTN4: {\n\t\tname: 'left',\n\t\tcode: 37,\n\t\tbangleVar: 'BTN4',\n\t\tactive: false,\n\t},\n\tBTN5: {\n\t\tname: 'right',\n\t\tcode: 39,\n\t\tbangleVar: 'BTN5',\n\t\tactive: false,\n\t},\n};\n\n[{ prop: 'keyup', active: false }, { prop: 'keydown', active: true }].forEach((eventType) => {\n\tdocument.addEventListener(eventType.prop as 'keyup' | 'keydown', (event: KeyboardEvent) => {\n\t\t(Object.keys(buttons) as ButtonIndex[]).forEach((key: ButtonIndex) => {\n\t\t\tif ((event.which || event.keyCode) === buttons[key].code) {\n\t\t\t\tbuttons[key].active = eventType.active;\n\t\t\t}\n\t\t});\n\t});\n});\n\nfunction clear() {\n\tcontext.fillStyle = '#EEEEEE';\n\tcontext.fillRect(0, 0, gameVariables.screenWidth, gameVariables.screenHeight);\n\tcontext.fillStyle = '#000000';\n}\n\nfunction flip() {\n}\n\nconst screenIo: ScreenIoOperations = {\n\tBTN1: {\n\t\tread: () => buttons.BTN1.active,\n\t},\n\tBTN2: {\n\t\tread: () => buttons.BTN2.active,\n\t},\n\tBTN3: {\n\t\tread: () => buttons.BTN3.active,\n\t},\n\tBTN4: {\n\t\tread: () => buttons.BTN4.active,\n\t},\n\tBTN5: {\n\t\tread: () => buttons.BTN5.active,\n\t},\n\tdrawPixel,\n\tdrawVerticalLine,\n\tclear,\n\tflip,\n\tdrawDebugGrid: showDebug ? drawDebugGrid : () => {},\n\tdrawDebugLine: showDebug ? drawDebugLine : () => {},\n\tdrawDebugPixel: showDebug ? drawDebugPixel : () => {},\n};\n\nlet context: CanvasRenderingContext2D;\nlet contextDebug: CanvasRenderingContext2D;\nwindow.onload = () => {\n\tconst canvas: HTMLCanvasElement | null = document.getElementById('canvas') as HTMLCanvasElement | null;\n\n\tif (canvas) {\n\t\tcanvas.width = gameVariables.screenWidth;\n\t\tcanvas.height = gameVariables.screenHeight;\n\t\tconst tempContext = canvas.getContext('2d');\n\t\tif (tempContext) {\n\t\t\tcontext = tempContext;\n\t\t} else {\n\t\t\tconsole.error('Failed to get the 2d canvas context');\n\t\t}\n\t} else {\n\t\tconsole.error('Failed to find canvas element');\n\t}\n\n\tif (showDebug) {\n\t\tconst canvasDebug: HTMLCanvasElement | null = document.getElementById('canvas-debug') as HTMLCanvasElement | null;\n\t\tif (canvasDebug) {\n\t\t\tcanvasDebug.width = debugWidth;\n\t\t\tcanvasDebug.height = debugHeight;\n\t\t\tconst tempContext = canvasDebug.getContext('2d');\n\t\t\tif (tempContext) {\n\t\t\t\tcontextDebug = tempContext;\n\t\t\t} else {\n\t\t\t\tconsole.error('Failed to get the 2d canvas context for debug');\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.error('Failed to find canvas element for debug');\n\t\t}\n\t}\n\n\tgameVariables.startGame(screenIo);\n\tconsole.log('starting maze runner');\n};\n\nconst debugWidth = gameVariables.mazeHorCells * debugCellSize;\nconst debugHeight = gameVariables.mazeVerCells * debugCellSize;\n\nfunction drawDebugGrid(maze: MazeElement[][]) {\n\tcontextDebug.fillStyle = '#FFFFFF';\n\tcontextDebug.clearRect(0, 0, debugWidth, debugHeight);\n\n\t// draw grid\n\tcontextDebug.strokeStyle = '#000000';\n\tfor (let row = 0; row < maze.length; row++) {\n\t\tfor (let col = 0; col < maze[0].length; col++) {\n\t\t\tconst mazeItem = maze[row][col];\n\t\t\tcontextDebug.strokeStyle = '#333333';\n\t\t\tif (mazeItem === MazeElement.WALL) {\n\t\t\t\tcontextDebug.fillStyle = '#000000';\n\t\t\t} else if (mazeItem === MazeElement.END) {\n\t\t\t\tcontextDebug.fillStyle = '#00FF00';\n\t\t\t} else { // Empty\n\t\t\t\tcontextDebug.fillStyle = '#FFFFFF';\n\t\t\t}\n\t\t\tcontextDebug.fillRect(col * debugCellSize, row * debugCellSize, debugCellSize, debugCellSize);\n\t\t\tcontextDebug.strokeRect(col * debugCellSize, row * debugCellSize, debugCellSize, debugCellSize);\n\t\t}\n\t}\n\n\t// draw player\n\tcontextDebug.fillStyle = '#0000FF';\n\tcontextDebug.fillRect(gameVariables.playerX * debugCellSize - 3, gameVariables.playerY * debugCellSize - 3, 7, 7);\n\n\t// draw viewAngle\n\tcontextDebug.strokeStyle = '#666666';\n\tcontextDebug.beginPath();\n\tcontextDebug.moveTo(gameVariables.playerX * debugCellSize, gameVariables.playerY * debugCellSize);\n\tcontextDebug.lineTo(gameVariables.playerX * debugCellSize + 1000 * cos(clampDeg(gameVariables.playerAngle - gameVariables.viewAngleWidth / 2)), gameVariables.playerY * debugCellSize + 1000 * sin(clampDeg(gameVariables.playerAngle - gameVariables.viewAngleWidth / 2)));\n\tcontextDebug.stroke();\n\tcontextDebug.beginPath();\n\tcontextDebug.moveTo(gameVariables.playerX * debugCellSize, gameVariables.playerY * debugCellSize);\n\tcontextDebug.lineTo(gameVariables.playerX * debugCellSize + 1000 * cos(clampDeg(gameVariables.playerAngle + gameVariables.viewAngleWidth / 2)), gameVariables.playerY * debugCellSize + 1000 * sin(clampDeg(gameVariables.playerAngle + gameVariables.viewAngleWidth / 2)));\n\tcontextDebug.stroke();\n}\n\nfunction drawDebugPixel(x: number, y: number, color: string = '#ff8e00') {\n\tcontextDebug.fillStyle = color;\n\tcontextDebug.fillRect(x * debugCellSize - 1, y * debugCellSize - 1, 3, 3);\n}\n\nfunction drawDebugLine(x1: number, y1: number, x2: number, y2: number, color: string = 'rgba(200, 200, 200, 0.5)') {\n\tcontextDebug.strokeStyle = color;\n\tcontextDebug.beginPath();\n\tcontextDebug.moveTo(x1 * debugCellSize, y1 * debugCellSize);\n\tcontextDebug.lineTo(x2 * debugCellSize, y2 * debugCellSize);\n\tcontextDebug.stroke();\n}\n\nfunction drawPixel(x: number, y: number) {\n\tif (x >= 0 && x < gameVariables.screenWidth && y >= 0 && y < gameVariables.screenHeight) {\n\t\tcontext.fillStyle = '#000000';\n\t\tcontext.fillRect(x, y, 1, 1);\n\t}\n}\n\nfunction drawVerticalLine(x: number, y1: number, y2: number) {\n\tfor (let i = y1; i <= y2; i++) {\n\t\tdrawPixel(x, i);\n\t}\n}\n"],"sourceRoot":""}