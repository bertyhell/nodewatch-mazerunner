{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/utils.ts","webpack:///./src/engine.ts","webpack:///./src/desktop.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","clampDeg","deg","cos","Math","PI","sin","tan","getSquareDistance","x1","y1","x2","y2","isOutsideMaze","maze","location","x","length","y","getUnvisitedNeighbors","currentPosition","filter","neighbor","generateMaze","width","height","generatedMaze","Array","row","col","unvisitedNeighbors","min","max","stack","push","pop","unvisitedNeighbor","floor","random","lastPlayerX","lastPlayerY","lastPlayerAngle","mazeWidth","mazeHeight","playerAngle","gameVars","screenWidth","screenHeight","viewAngleWidth","angleStep","playerStepSize","mazeHorCells","mazeVerCells","playerX","playerY","startGame","screenIo","stopGame","CORNERS","running","getCollisionDistance","viewAngle","outerRay","debugOperations","horCollision","vertCollision","initialHorIntersectionX","initialHorIntersectionY","initialVertIntersectionX","initialVertIntersectionY","horizontalOffsetX","horizontalOffsetY","verticalOffsetX","verticalOffsetY","isFacingUp","isFacingRight","horIntersectionX","horIntersectionY","horGridLocation","vertIntersectionX","vertIntersectionY","vertGridLocation","quadrant","intersectionOffset","drawDebugPixel","abs","closestCollision","drawDebugLine","Error","isInsideWall","movePlayer","deltaX","deltaY","newPlayerX","newPlayerY","onFrame","BTN4","read","BTN5","playerXDelta","playerYDelta","BTN1","BTN2","clear","drawDebugGrid","startAngle","raytraceStepAngle","anglesCollisionsAndDistances","collision","perpendicularDistance","sqrt","angle","distance","shouldDrawWall","intersectionPoints","forEach","angCollDis","intersectionX","round","intersectionY","cornerIntersectionPoints","keys","intersectionKey","intersection","topLeftCell","topRightCell","bottomLeftCell","bottomRightCell","shortestDistance","closestCollisionIndex","collisionInfo","index","wallHeight","drawVerticalLine","drawPixel","drawWalls","flip","setTimeout","gameVariables","debugCellSize","buttons","code","bangleVar","active","BTN3","prop","eventType","document","addEventListener","event","which","keyCode","context","fillStyle","fillRect","window","onload","tempContext","canvas","getElementById","getContext","console","error","log"],"mappings":"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","file":"desktop.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","import { MazeElement, Point } from './types';\n\nexport function clampDeg(deg: number): number {\n\treturn (deg + 360) % 360;\n}\n\n\n// /**\n//  * Generates a lookup table for trigonometric functions\n//  * The keys will be the degrees times 10, so we can easily round to 0.1 degree\n//  * @param trigonometricFunction\n//  */\n// function getLookupTable(trigonometricFunction: (rad: number) => number): { [deg: number]: number } {\n// \tconst lookup: { [deg: number]: number } = {};\n// \tfor (let i = 0; i <= 360; i += 1) {\n// \t\tlookup[Math.round(i)] = trigonometricFunction(i / 180 * Math.PI);\n// \t}\n// \treturn lookup;\n// }\n//\n// const cosLookupTable: { [deg: number]: number } = getLookupTable(Math.cos);\n// const sinLookupTable: { [deg: number]: number } = getLookupTable(Math.sin);\n// const tanLookupTable: { [deg: number]: number } = getLookupTable(Math.tan);\n//\n// function lookupAndInterpolate(deg: number, lookupTable: { [deg: number]: number }): number {\n// \tconst lowerDeg = Math.floor(deg);\n// \tconst upperDeg = Math.ceil(deg + 0.00001);\n// \tconst lowerTri = lookupTable[lowerDeg];\n// \tconst upperTri = lookupTable[upperDeg];\n// \tconst diffDeg = upperDeg - lowerDeg;\n// \tconst diffCos = upperTri - lowerTri;\n// \treturn lowerTri + Math.abs(deg - lowerDeg) / diffDeg * diffCos;\n// }\n\n// export function cos(deg: number): number {\n// \treturn lookupAndInterpolate(deg, cosLookupTable);\n// }\n//\n// export function sin(deg: number): number {\n// \treturn lookupAndInterpolate(deg, sinLookupTable);\n// }\n//\n// export function tan(deg: number): number {\n// \treturn lookupAndInterpolate(deg, tanLookupTable);\n// }\n\nexport function cos(deg: number): number {\n\treturn Math.cos(deg / 180 * Math.PI);\n}\n\nexport function sin(deg: number): number {\n\treturn Math.sin(deg / 180 * Math.PI);\n}\n\nexport function tan(deg: number): number {\n\treturn Math.tan(deg / 180 * Math.PI);\n}\n\nexport function getSquareDistance(x1: number, y1: number, x2: number, y2: number) {\n\treturn (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n}\n\nexport function isOutsideMaze(maze: MazeElement[][], location: Point): boolean {\n\treturn !(location.x >= 0 && location.x < maze[0].length && location.y >= 0 && location.y < maze.length);\n}\n\nfunction getUnvisitedNeighbors(maze: MazeElement[][], currentPosition: Point): Point[] {\n\tconst neighbors: Point[] = [\n\t\t{ x: currentPosition.x - 2, y: currentPosition.y }, // left\n\t\t{ x: currentPosition.x, y: currentPosition.y - 2 }, // top\n\t\t{ x: currentPosition.x + 2, y: currentPosition.y }, // right\n\t\t{ x: currentPosition.x, y: currentPosition.y + 2 }, // bottom\n\t];\n\treturn neighbors.filter(neighbor => {\n\t\treturn !isOutsideMaze(maze, neighbor) && maze[neighbor.y][neighbor.x] === MazeElement.UNVISITED_EMPTY;\n\t});\n}\n\n/**\n * Generate random number inside the interval [min, max]\n * min and max included\n * @param min\n * @param max\n */\nfunction randomInt(min: number, max: number) {\n\treturn Math.floor(Math.random() * (max - min + 1) + min);\n}\n\n/**\n * Generate a maze using a depth first search algorthm with backtracking\n * https://en.wikipedia.org/wiki/Maze_generation_algorithm\n * 1. Choose the initial cell, mark it as visited and push it to the stack\n * 2. While the stack is not empty\n *      1. Pop a cell from the stack and make it a current cell\n *      2. If the current cell has any neighbours which have not been visited\n *            1. Push the current cell to the stack\n *            2. Choose one of the unvisited neighbours\n *            3. Remove the wall between the current cell and the chosen cell\n *            4. Mark the chosen cell as visited and push it to the stack\n * @param width\n * @param height\n */\nexport function generateMaze(width: number, height: number): MazeElement[][] {\n\tconst generatedMaze: MazeElement[][] = new Array<MazeElement[]>(height);\n\t// Init maze like:\n\t// 111111111\n\t// 101010101\n\t// 111111111\n\t// 101010101\n\t// 111111111\n\t// 101010101\n\t// 111111111\n\tfor (let row = 0; row < height; row++) {\n\t\tgeneratedMaze[row] = new Array<MazeElement>(width);\n\t\tfor (let col = 0; col < width; col++) {\n\t\t\tif (row % 2 === 0 || col % 2 === 0) {\n\t\t\t\tgeneratedMaze[row][col] = MazeElement.WALL;\n\t\t\t} else {\n\t\t\t\tgeneratedMaze[row][col] = MazeElement.UNVISITED_EMPTY; // Empty not yet visited, we'll switch this to 0 once we visit the cell during the algorithm\n\t\t\t}\n\t\t}\n\t}\n\t// Remove hedges between empty cells based on maze generation algorithm\n\tconst stack: Point[] = [];\n\tlet currentPosition: Point = { x: 1, y: 1 };\n\tgeneratedMaze[currentPosition.y][currentPosition.x] = 0;\n\tstack.push(currentPosition);\n\tlet unvisitedNeighbors: Point[];\n\twhile (stack.length) {\n\t\tcurrentPosition = stack.pop() as Point;\n\t\tunvisitedNeighbors = getUnvisitedNeighbors(generatedMaze, currentPosition);\n\t\tif (unvisitedNeighbors.length) {\n\t\t\tstack.push(currentPosition);\n\t\t\tconst unvisitedNeighbor = unvisitedNeighbors[randomInt(0, unvisitedNeighbors.length - 1)];\n\t\t\t// Remove hedge\n\t\t\tgeneratedMaze[(unvisitedNeighbor.y + currentPosition.y) / 2][(unvisitedNeighbor.x + currentPosition.x) / 2] = 0;\n\t\t\t// Mark the neighbor as visited\n\t\t\tgeneratedMaze[unvisitedNeighbor.y][unvisitedNeighbor.x] = 0;\n\t\t\tstack.push(unvisitedNeighbor);\n\t\t}\n\t}\n\n\t// Set start and endpoint\n\tgeneratedMaze[1][1] = MazeElement.PLAYER;\n\tgeneratedMaze[height - 2][width - 2] = MazeElement.END;\n\n\treturn generatedMaze;\n}\n","import { ScreenIoOperations, MazeElement, Point, Quadrant } from './types';\nimport { clampDeg, cos, generateMaze, getSquareDistance, isOutsideMaze, sin, tan } from './utils';\n\nconst mazeWidth = 3;\nconst mazeHeight = 3;\nconst screenWidth = 240;\nconst screenHeight = 160;\nconst playerX = 1.5;\nconst playerY = 1.5;\nconst viewAngleWidth = 70;\nconst angleStep = 7;\nconst playerStepSize = 0.1;\nconst mazeHorCells = mazeWidth * 2 + 1;\nconst mazeVerCells = mazeHeight * 2 + 1;\n\nconst maze: MazeElement[][] = generateMaze(mazeHorCells, mazeVerCells);\n// let maze: MazeElement[][] = [\n// \t[1, 1, 1, 1, 1, 1, 1],\n// \t[1, 0, 0, 0, 1, 0, 1],\n// \t[1, 0, 1, 0, 0, 0, 1],\n// \t[1, 0, 1, 0, 1, 0, 1],\n// \t[1, 2, 1, 0, 1, 3, 1],\n// \t[1, 1, 1, 1, 1, 1, 1]\n// ];\n\nconst playerAngle: number = (maze[1][2] === MazeElement.WALL ? 90 : 0);\n\n// Game variables\nconst gameVars = {\n\tmazeWidth,\n\tmazeHeight,\n\tscreenWidth,\n\tscreenHeight,\n\tviewAngleWidth,\n\tangleStep,\n\tplayerStepSize,\n\n\t// Computed values\n\tmazeHorCells,\n\tmazeVerCells,\n\tplayerX,\n\tplayerY,\n\tmaze,\n\t// point te player towards the hallway instead of towards a wall\n\t// Checks if the cell to the right of the player is a wall, if so, point the player down (90), else to the right (0)\n\tplayerAngle,\n\n\tstartGame: (screenIo: ScreenIoOperations) => {},\n\tstopGame: () => {},\n};\n\n// Determines if we should draw a vertical wall line for the given intersections at the center of these 4 maze cells:\n// +-----+\n// |0 |1 |\n// +-----+\n// |2 |3 |\n// +-----+\n//\n// eg: 1000 => should draw a wall at the X\n// +--+--+\n// |W |  |\n// +--X--+\n// |  |  |\n// +--+--+\n//\n// eg: 1010 => should not draw a wall at the X since the wall is smoothly running from top to bottom across the intersection\n// +--+--+\n// |W |  |\n// +--X--+\n// |W |  |\n// +--+--+\n//\n// We can assume the X location is always visible from the user's perspective\nconst CORNERS: { [cornerKey: string]: boolean } = {\n\t'0000': false,\n\t'0001': true,\n\t'0010': true,\n\t'0011': false,\n\t'0100': true,\n\t'0101': false,\n\t'0110': false,\n\t'0111': true,\n\t'1000': true,\n\t'1001': true,\n\t'1010': false,\n\t'1011': true,\n\t'1100': false,\n\t'1101': true,\n\t'1110': true,\n\t'1111': false,\n};\n\nlet running = true;\n\n\n\n// } else {\n// \tglobals = {\n// \t\tBangle: Bangle,\n// \t\tg: g,\n// \t\tBTNU: BTN1,\n// \t\tBTND: BTN2,\n// \t\tBTNL: BTN4,\n// \t\tBTNR: BTN5,\n// \t};\n// }\n\nfunction startGame(screenIo: ScreenIoOperations) {\n\trunning = true;\n\tonFrame(screenIo);\n}\n\nfunction stopGame() {\n\trunning = false;\n\t// globals.g.clear();\n\t// globals.g.drawString('Game Over!', 120, (gameVariables.screenHeight - 6) / 2);\n\t// globals.g.flip();\n}\n\n/**\n * https://www.permadi.com/tutorial/raycast/rayc7.html\n */\nfunction getCollisionDistance(viewAngle: number, outerRay: boolean, debugOperations: ScreenIoOperations): Point {\n\tconst quadrant: Quadrant = Math.floor(viewAngle / 90);\n\n\tlet horCollision: Point | undefined; // first intersection with a wall\n\tlet vertCollision: Point | undefined; // first intersection with a wall\n\tlet intersectionOffset: number = 0; // number of intersections to skip since the ones before were not an intersection with a wall\n\tlet initialHorIntersectionX: number | undefined; // first intersection with horizontal gridline\n\tlet initialHorIntersectionY: number | undefined;\n\tlet initialVertIntersectionX: number | undefined; // first intersection with vertical gridline\n\tlet initialVertIntersectionY: number | undefined;\n\tlet horizontalOffsetX: number | undefined; // distance between horizontal intersections\n\tlet horizontalOffsetY: number | undefined;\n\tlet verticalOffsetX: number | undefined; // distance between vertical intersections\n\tlet verticalOffsetY: number | undefined;\n\tlet isFacingUp: boolean;\n\tlet isFacingRight: boolean;\n\tlet horIntersectionX: number;\n\tlet horIntersectionY: number;\n\tlet horGridLocation: Point;\n\tlet vertIntersectionX: number;\n\tlet vertIntersectionY: number;\n\tlet vertGridLocation: Point;\n\n\twhile (!horCollision || !vertCollision) {\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\t// horizontal intersection\n\t\tif (!horCollision) {\n\t\t\tif (!initialHorIntersectionX) {\n\t\t\t\tif (isFacingUp) {\n\t\t\t\t\tinitialHorIntersectionY = Math.floor(gameVars.playerY);\n\t\t\t\t} else {\n\t\t\t\t\tinitialHorIntersectionY = Math.floor(gameVars.playerY) + 1;\n\t\t\t\t}\n\t\t\t\tinitialHorIntersectionX = gameVars.playerX - (gameVars.playerY - initialHorIntersectionY) / tan(viewAngle);\n\t\t\t}\n\t\t\tif (intersectionOffset !== 0 && !horizontalOffsetX) {\n\t\t\t\tif (isFacingUp) {\n\t\t\t\t\thorizontalOffsetY = -1;\n\t\t\t\t} else {\n\t\t\t\t\thorizontalOffsetY = 1;\n\t\t\t\t}\n\t\t\t\thorizontalOffsetX = 1 / tan(viewAngle);\n\t\t\t}\n\t\t\thorIntersectionX = initialHorIntersectionX + (horizontalOffsetX || 0) * intersectionOffset * (isFacingUp ? -1 : 1);\n\t\t\thorIntersectionY = initialHorIntersectionY as number + (horizontalOffsetY || 0) * intersectionOffset;\n\t\t\thorGridLocation = {\n\t\t\t\tx: Math.floor(horIntersectionX),\n\t\t\t\ty: Math.floor(horIntersectionY) + (isFacingUp ? -1 : 0),\n\t\t\t};\n\t\t\tif (isOutsideMaze(maze, horGridLocation) || maze[horGridLocation.y][horGridLocation.x] === MazeElement.WALL) {\n\t\t\t\tif (outerRay) debugOperations.drawDebugPixel(horIntersectionX, horIntersectionY);\n\t\t\t\thorCollision = { x: horIntersectionX, y: horIntersectionY };\n\t\t\t} else {\n\t\t\t\tif (outerRay) debugOperations.drawDebugPixel(horIntersectionX, horIntersectionY, '#FF0000');\n\t\t\t}\n\t\t}\n\n\t\t// Vertical intersection\n\t\tisFacingRight = quadrant === Quadrant.BottomRight || quadrant === Quadrant.TopRight;\n\n\t\tif (!vertCollision) {\n\t\t\tif (!initialVertIntersectionX) {\n\t\t\t\tif (isFacingRight) {\n\t\t\t\t\tinitialVertIntersectionX = Math.floor(gameVars.playerX) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tinitialVertIntersectionX = Math.floor(gameVars.playerX);\n\t\t\t\t}\n\t\t\t\tinitialVertIntersectionY = gameVars.playerY - (gameVars.playerX - initialVertIntersectionX) * tan(viewAngle);\n\t\t\t}\n\t\t\tif (intersectionOffset !== 0 && !verticalOffsetX) {\n\t\t\t\tverticalOffsetX = isFacingRight ? 1 : -1;\n\t\t\t\tverticalOffsetY = Math.abs(tan(viewAngle)) * (isFacingUp ? -1 : 1);\n\t\t\t}\n\n\t\t\tvertIntersectionX = initialVertIntersectionX + (verticalOffsetX || 0) * intersectionOffset;\n\t\t\tvertIntersectionY = initialVertIntersectionY as number + (verticalOffsetY || 0) * intersectionOffset;\n\t\t\tvertGridLocation = {\n\t\t\t\tx: Math.floor(vertIntersectionX) + (isFacingRight ? 0 : -1),\n\t\t\t\ty: Math.floor(vertIntersectionY),\n\t\t\t};\n\t\t\tif (isOutsideMaze(maze, vertGridLocation) || maze[vertGridLocation.y][vertGridLocation.x] === MazeElement.WALL) {\n\t\t\t\tif (outerRay) debugOperations.drawDebugPixel(vertIntersectionX, vertIntersectionY);\n\t\t\t\tvertCollision = { x: vertIntersectionX, y: vertIntersectionY };\n\t\t\t} else {\n\t\t\t\tif (outerRay) debugOperations.drawDebugPixel(vertIntersectionX, vertIntersectionY, '#FF0000');\n\t\t\t}\n\t\t}\n\t\tintersectionOffset++;\n\t}\n\tconst horDistance = getSquareDistance(gameVars.playerX, gameVars.playerY, horCollision.x, horCollision.y);\n\tconst vertDistance = getSquareDistance(gameVars.playerX, gameVars.playerY, vertCollision.x, vertCollision.y);\n\tconst closestCollision: Point = horDistance < vertDistance ? horCollision : vertCollision;\n\tif (outerRay) debugOperations.drawDebugPixel(closestCollision.x, closestCollision.y, '#00FF00');\n\tdebugOperations.drawDebugLine(gameVars.playerX, gameVars.playerY, closestCollision.x, closestCollision.y);\n\n\tif (!closestCollision) {\n\t\tthrow new Error('intersection is null');\n\t}\n\n\treturn closestCollision;\n}\n\ninterface CollisionInfo {\n\tangle: number;\n\tcollision: Point;\n\tdistance: number;\n\tshouldDrawWall: boolean;\n}\n\nfunction drawWalls(screenIo: ScreenIoOperations) {\n\t// console.log('--------------------------');\n\tscreenIo.drawDebugGrid(maze);\n\n\t// console.log('player angle: ', playerAngle);\n\n\tconst startAngle = clampDeg(gameVars.playerAngle - gameVars.viewAngleWidth / 2);\n\tconst raytraceStepAngle = gameVars.viewAngleWidth / gameVars.screenWidth;\n\tconst anglesCollisionsAndDistances: CollisionInfo[] = [];\n\tfor (let i = 0; i < gameVars.screenWidth; i += 1) {\n\t\tconst viewAngle = clampDeg(startAngle + raytraceStepAngle * i);\n\t\tconst collision: Point = getCollisionDistance(viewAngle, i === 0 || i >= gameVars.screenWidth - 1, screenIo);\n\t\tconst directDistance = Math.sqrt(getSquareDistance(gameVars.playerX, gameVars.playerY, collision.x, collision.y));\n\t\tconst perpendicularDistance = directDistance * cos(clampDeg(viewAngle - gameVars.playerAngle));\n\n\t\tanglesCollisionsAndDistances.push({\n\t\t\tangle: viewAngle,\n\t\t\tcollision,\n\t\t\tdistance: perpendicularDistance,\n\t\t\tshouldDrawWall: false,\n\t\t});\n\t}\n\n\t// Identify which rays should also draw a vertical line to identify corners\n\t// Find unique intersection point in the maze which are closest to each collision\n\tconst intersectionPoints: { [coord: string]: Point } = {};\n\tanglesCollisionsAndDistances.forEach(angCollDis => {\n\t\tconst intersectionX = Math.round(angCollDis.collision.x);\n\t\tconst intersectionY = Math.round(angCollDis.collision.y);\n\t\tintersectionPoints[intersectionX + ';' + intersectionY] = { x: intersectionX, y: intersectionY };\n\t});\n\t// Identify if the intersection should cause a wall line to be displayed or if it is part of a straight wall\n\tconst cornerIntersectionPoints: Point[] = [];\n\tObject.keys(intersectionPoints).forEach(intersectionKey => {\n\t\tconst intersection = intersectionPoints[intersectionKey];\n\t\tconst topLeftCell = maze[intersection.y - 1][intersection.x - 1];\n\t\tconst topRightCell = maze[intersection.y - 1][intersection.x];\n\t\tconst bottomLeftCell = maze[intersection.y][intersection.x - 1];\n\t\tconst bottomRightCell = maze[intersection.y][intersection.x];\n\n\t\t// Generate corner key: eg: 1100 or 1010\n\t\tconst cornerKey: string =\n\t\t\t(topLeftCell === MazeElement.WALL ? '1' : '0') +\n\t\t\t(topRightCell === MazeElement.WALL ? '1' : '0') +\n\t\t\t(bottomLeftCell === MazeElement.WALL ? '1' : '0') +\n\t\t\t(bottomRightCell === MazeElement.WALL ? '1' : '0');\n\t\tconst shouldDrawWall = CORNERS[cornerKey];\n\t\tif (shouldDrawWall) {\n\t\t\tcornerIntersectionPoints.push(intersection);\n\t\t}\n\t});\n\n\t// Find the closest collision to each corner intersection\n\tcornerIntersectionPoints.forEach(intersection => {\n\t\tlet shortestDistance = 100000;\n\t\tlet closestCollisionIndex = 0;\n\t\tanglesCollisionsAndDistances.forEach((collisionInfo: CollisionInfo, index: number) => {\n\t\t\tconst distance = Math.abs(intersection.x - collisionInfo.collision.x) + Math.abs(intersection.y - collisionInfo.collision.y);\n\t\t\tif (distance < shortestDistance) {\n\t\t\t\tclosestCollisionIndex = index;\n\t\t\t\tshortestDistance = distance;\n\t\t\t}\n\t\t});\n\t\tanglesCollisionsAndDistances[closestCollisionIndex].shouldDrawWall = true;\n\t});\n\n\t// Draw the walls\n\tanglesCollisionsAndDistances.forEach((collisionInfo: CollisionInfo, index: number) => {\n\t\tlet wallHeight = gameVars.screenHeight / collisionInfo.distance;\n\n\t\tif (collisionInfo.shouldDrawWall) {\n\t\t\tscreenIo.drawVerticalLine(index, Math.round((gameVars.screenHeight - wallHeight) / 2), Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t\t} else {\n\t\t\tscreenIo.drawPixel(index, Math.round((gameVars.screenHeight - wallHeight) / 2));\n\t\t\tscreenIo.drawPixel(index, Math.round((gameVars.screenHeight - wallHeight) / 2 + wallHeight));\n\t\t}\n\t});\n}\n\nfunction isInsideWall(playerX: number, playerY: number) {\n\treturn maze[Math.floor(playerY)][Math.floor(playerX)] === MazeElement.WALL;\n}\n\nfunction movePlayer(deltaX: number, deltaY: number) {\n\t// Try moving in both directions\n\tlet newPlayerX = gameVars.playerX + deltaX;\n\tlet newPlayerY = gameVars.playerY + deltaY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n\t// Try moving in the y direction only\n\tnewPlayerX = gameVars.playerX;\n\tnewPlayerY = gameVars.playerY + deltaY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n\t// Try moving in the x direction only\n\tnewPlayerX = gameVars.playerX + deltaX;\n\tnewPlayerY = gameVars.playerY;\n\tif (!isInsideWall(newPlayerX, newPlayerY)) {\n\t\tgameVars.playerX = newPlayerX;\n\t\tgameVars.playerY = newPlayerY;\n\t\treturn;\n\t}\n}\n\nlet lastPlayerX: number | undefined;\nlet lastPlayerY: number | undefined;\nlet lastPlayerAngle: number | undefined;\n\nfunction onFrame(screenIo: ScreenIoOperations) {\n\t// let t = getTime();\n\t// let d = (lastFrame===undefined)?0:(t-lastFrame)*20;\n\t// lastFrame = t;\n\n\tif (screenIo.BTN4.read()) {\n\t\t// console.log('left');\n\t\tgameVars.playerAngle = clampDeg(gameVars.playerAngle - gameVars.angleStep);\n\t}\n\tif (screenIo.BTN5.read()) {\n\t\t// console.log('right');\n\t\tgameVars.playerAngle = clampDeg(gameVars.playerAngle + gameVars.angleStep);\n\t}\n\tlet quadrant: Quadrant;\n\tlet isFacingUp: boolean;\n\tlet isFacingRight: boolean;\n\tlet playerXDelta: number;\n\tlet playerYDelta: number;\n\tif (screenIo.BTN1.read()) {\n\t\t// console.log('forward');\n\n\t\tquadrant = Math.floor(gameVars.playerAngle / 90);\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\tisFacingRight = quadrant === Quadrant.TopRight || quadrant === Quadrant.BottomRight;\n\t\tplayerXDelta = Math.abs(cos(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingRight ? 1 : -1);\n\t\tplayerYDelta = Math.abs(sin(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingUp ? -1 : 1);\n\t\tmovePlayer(playerXDelta, playerYDelta);\n\t}\n\tif (screenIo.BTN2.read()) {\n\t\t// console.log('backward');\n\n\t\tquadrant = Math.floor(gameVars.playerAngle / 90);\n\t\tisFacingUp = quadrant === Quadrant.TopLeft || quadrant === Quadrant.TopRight;\n\t\tisFacingRight = quadrant === Quadrant.TopRight || quadrant === Quadrant.BottomRight;\n\t\tplayerXDelta = Math.abs(cos(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingRight ? -1 : 1);\n\t\tplayerYDelta = Math.abs(sin(gameVars.playerAngle) * gameVars.playerStepSize) * (isFacingUp ? 1 : -1);\n\t\tmovePlayer(playerXDelta, playerYDelta);\n\t}\n\n\tif (!running) {\n\t\t// if (BTNA.read()) gameStart();\n\t\treturn;\n\t}\n\n\tif (lastPlayerX !== gameVars.playerX ||\n\t\tlastPlayerY !== gameVars.playerY ||\n\t\tlastPlayerAngle !== gameVars.playerAngle) {\n\t\t// console.log('start draw cycle');\n\t\tscreenIo.clear();\n\t\tdrawWalls(screenIo);\n\t\tscreenIo.flip();\n\t\t// console.log('finished draw cycle');\n\t}\n\n\tlastPlayerX = gameVars.playerX;\n\tlastPlayerY = gameVars.playerY;\n\tlastPlayerAngle = gameVars.playerAngle;\n\tsetTimeout(() => onFrame(screenIo), 50);\n}\n\ngameVars.startGame = startGame;\ngameVars.stopGame = stopGame;\n\nexport const gameVariables = gameVars;\n","import { gameVariables } from './engine';\nimport { ButtonIndex, MazeElement, ScreenIoOperations } from './types';\nimport { clampDeg, cos, sin } from './utils';\n\nconst debugCellSize = 20;\nconst showDebug = false;\n\ninterface ButtonInfo {\n\tname: 'up' | 'down' | 'menu' | 'left' | 'right';\n\tcode: 9 | 37 | 38 | 39 | 40;\n\tbangleVar: ButtonIndex;\n\tactive: boolean;\n}\n\nconst buttons: { [key in ButtonIndex]: ButtonInfo } = {\n\tBTN1: {\n\t\tname: 'up',\n\t\tcode: 38,\n\t\tbangleVar: 'BTN1',\n\t\tactive: false,\n\t},\n\tBTN2: {\n\t\tname: 'down',\n\t\tcode: 40,\n\t\tbangleVar: 'BTN2',\n\t\tactive: false,\n\t},\n\tBTN3: {\n\t\tname: 'menu',\n\t\tcode: 9,\n\t\tbangleVar: 'BTN3',\n\t\tactive: false,\n\t},\n\tBTN4: {\n\t\tname: 'left',\n\t\tcode: 37,\n\t\tbangleVar: 'BTN4',\n\t\tactive: false,\n\t},\n\tBTN5: {\n\t\tname: 'right',\n\t\tcode: 39,\n\t\tbangleVar: 'BTN5',\n\t\tactive: false,\n\t},\n};\n\n[{ prop: 'keyup', active: false }, { prop: 'keydown', active: true }].forEach((eventType) => {\n\tdocument.addEventListener(eventType.prop as 'keyup' | 'keydown', (event: KeyboardEvent) => {\n\t\t(Object.keys(buttons) as ButtonIndex[]).forEach((key: ButtonIndex) => {\n\t\t\tif ((event.which || event.keyCode) === buttons[key].code) {\n\t\t\t\tbuttons[key].active = eventType.active;\n\t\t\t}\n\t\t});\n\t});\n});\n\nfunction clear() {\n\tcontext.fillStyle = '#EEEEEE';\n\tcontext.fillRect(0, 0, gameVariables.screenWidth, gameVariables.screenHeight);\n\tcontext.fillStyle = '#000000';\n}\n\nfunction flip() {\n}\n\nconst screenIo: ScreenIoOperations = {\n\tBTN1: {\n\t\tread: () => buttons.BTN1.active,\n\t},\n\tBTN2: {\n\t\tread: () => buttons.BTN2.active,\n\t},\n\tBTN3: {\n\t\tread: () => buttons.BTN3.active,\n\t},\n\tBTN4: {\n\t\tread: () => buttons.BTN4.active,\n\t},\n\tBTN5: {\n\t\tread: () => buttons.BTN5.active,\n\t},\n\tdrawPixel,\n\tdrawVerticalLine,\n\tclear,\n\tflip,\n\tdrawDebugGrid: showDebug ? drawDebugGrid : () => {},\n\tdrawDebugLine: showDebug ? drawDebugLine : () => {},\n\tdrawDebugPixel: showDebug ? drawDebugPixel : () => {},\n};\n\nlet context: CanvasRenderingContext2D;\nlet contextDebug: CanvasRenderingContext2D;\nwindow.onload = () => {\n\tconst canvas: HTMLCanvasElement | null = document.getElementById('canvas') as HTMLCanvasElement | null;\n\n\tif (canvas) {\n\t\tcanvas.width = gameVariables.screenWidth;\n\t\tcanvas.height = gameVariables.screenHeight;\n\t\tconst tempContext = canvas.getContext('2d');\n\t\tif (tempContext) {\n\t\t\tcontext = tempContext;\n\t\t} else {\n\t\t\tconsole.error('Failed to get the 2d canvas context');\n\t\t}\n\t} else {\n\t\tconsole.error('Failed to find canvas element');\n\t}\n\n\tif (showDebug) {\n\t\tconst canvasDebug: HTMLCanvasElement | null = document.getElementById('canvas-debug') as HTMLCanvasElement | null;\n\t\tif (canvasDebug) {\n\t\t\tcanvasDebug.width = debugWidth;\n\t\t\tcanvasDebug.height = debugHeight;\n\t\t\tconst tempContext = canvasDebug.getContext('2d');\n\t\t\tif (tempContext) {\n\t\t\t\tcontextDebug = tempContext;\n\t\t\t} else {\n\t\t\t\tconsole.error('Failed to get the 2d canvas context for debug');\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.error('Failed to find canvas element for debug');\n\t\t}\n\t}\n\n\tgameVariables.startGame(screenIo);\n\tconsole.log('starting maze runner');\n};\n\nconst debugWidth = gameVariables.mazeHorCells * debugCellSize;\nconst debugHeight = gameVariables.mazeVerCells * debugCellSize;\n\nfunction drawDebugGrid(maze: MazeElement[][]) {\n\tcontextDebug.fillStyle = '#FFFFFF';\n\tcontextDebug.clearRect(0, 0, debugWidth, debugHeight);\n\n\t// draw grid\n\tcontextDebug.strokeStyle = '#000000';\n\tfor (let row = 0; row < maze.length; row++) {\n\t\tfor (let col = 0; col < maze[0].length; col++) {\n\t\t\tconst mazeItem = maze[row][col];\n\t\t\tcontextDebug.strokeStyle = '#333333';\n\t\t\tif (mazeItem === MazeElement.WALL) {\n\t\t\t\tcontextDebug.fillStyle = '#000000';\n\t\t\t} else if (mazeItem === MazeElement.END) {\n\t\t\t\tcontextDebug.fillStyle = '#00FF00';\n\t\t\t} else { // Empty\n\t\t\t\tcontextDebug.fillStyle = '#FFFFFF';\n\t\t\t}\n\t\t\tcontextDebug.fillRect(col * debugCellSize, row * debugCellSize, debugCellSize, debugCellSize);\n\t\t\tcontextDebug.strokeRect(col * debugCellSize, row * debugCellSize, debugCellSize, debugCellSize);\n\t\t}\n\t}\n\n\t// draw player\n\tcontextDebug.fillStyle = '#0000FF';\n\tcontextDebug.fillRect(gameVariables.playerX * debugCellSize - 3, gameVariables.playerY * debugCellSize - 3, 7, 7);\n\n\t// draw viewAngle\n\tcontextDebug.strokeStyle = '#666666';\n\tcontextDebug.beginPath();\n\tcontextDebug.moveTo(gameVariables.playerX * debugCellSize, gameVariables.playerY * debugCellSize);\n\tcontextDebug.lineTo(gameVariables.playerX * debugCellSize + 1000 * cos(clampDeg(gameVariables.playerAngle - gameVariables.viewAngleWidth / 2)), gameVariables.playerY * debugCellSize + 1000 * sin(clampDeg(gameVariables.playerAngle - gameVariables.viewAngleWidth / 2)));\n\tcontextDebug.stroke();\n\tcontextDebug.beginPath();\n\tcontextDebug.moveTo(gameVariables.playerX * debugCellSize, gameVariables.playerY * debugCellSize);\n\tcontextDebug.lineTo(gameVariables.playerX * debugCellSize + 1000 * cos(clampDeg(gameVariables.playerAngle + gameVariables.viewAngleWidth / 2)), gameVariables.playerY * debugCellSize + 1000 * sin(clampDeg(gameVariables.playerAngle + gameVariables.viewAngleWidth / 2)));\n\tcontextDebug.stroke();\n}\n\nfunction drawDebugPixel(x: number, y: number, color: string = '#ff8e00') {\n\tcontextDebug.fillStyle = color;\n\tcontextDebug.fillRect(x * debugCellSize - 1, y * debugCellSize - 1, 3, 3);\n}\n\nfunction drawDebugLine(x1: number, y1: number, x2: number, y2: number, color: string = 'rgba(200, 200, 200, 0.5)') {\n\tcontextDebug.strokeStyle = color;\n\tcontextDebug.beginPath();\n\tcontextDebug.moveTo(x1 * debugCellSize, y1 * debugCellSize);\n\tcontextDebug.lineTo(x2 * debugCellSize, y2 * debugCellSize);\n\tcontextDebug.stroke();\n}\n\nfunction drawPixel(x: number, y: number) {\n\tif (x >= 0 && x < gameVariables.screenWidth && y >= 0 && y < gameVariables.screenHeight) {\n\t\tcontext.fillStyle = '#000000';\n\t\tcontext.fillRect(x, y, 1, 1);\n\t}\n}\n\nfunction drawVerticalLine(x: number, y1: number, y2: number) {\n\tfor (let i = y1; i <= y2; i++) {\n\t\tdrawPixel(x, i);\n\t}\n}\n"],"sourceRoot":""}